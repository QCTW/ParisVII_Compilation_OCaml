make: Entering directory '/home/opam/source/flap/tests-flap'
make -C ..
make[1]: Entering directory '/home/opam/source/flap'
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
make[1]: Leaving directory '/home/opam/source/flap'
make[1]: Entering directory '/home/opam/source/flap/tests-flap'
make[1]: Leaving directory '/home/opam/source/flap/tests-flap'
make[1]: Entering directory '/home/opam/source/flap/tests-flap/hopix/fopix/good'
========================================================
In fopix/good
[ OK ]   adt.hopix

INPUT:
type list = Nil | Cons (int, list)

val nil = Nil
val l1 = Cons (1, Cons (2, nil))
val l2 = Cons (0, l1)
val main =
  l2 ? {
  | Nil => print_string ("Wrong!\n")
  | Cons (x, _) => print_int (x)
  };
  print_string ("!\n")

OUTPUT: 
0!
EXPECTED: 
0!
--------------------------------------------------------
[ OK ]   adt1.hopix

INPUT:
type list = Nil | Cons (int, list)

val nil = Nil
val l1 = Cons (1, Cons (2, nil))
val l2 = Cons (0, l1)
val main =
  l2 ? {
  | Nil => print_string ("Wrong!\n")
  | Cons (x, xs) =>
    xs ? {
    | Nil => print_string ("Wrong!\n")
    | Cons (y, _) => print_int (y)
    }
  };
  print_string ("!\n")

OUTPUT: 
1!
EXPECTED: 
1!
--------------------------------------------------------
[ OK ]   adt2.hopix

INPUT:
type list = Nil | Cons (int, list)

val nil = Nil
val l1 = Cons (1, Cons (2, nil))
val l2 = Cons (0, l1)
fun len (l) = l ? { Nil => 0 | Cons (_, xs) => 1 + len (xs) }

val main =
  print_int (len (l1));
  print_string ("!\n")

OUTPUT: 
2!
EXPECTED: 
2!
--------------------------------------------------------
[ KO ]   -->  adt3.hopix

INPUT:
type list = Nil | Cons (int, list)

val nil = Nil
val l1 = Cons (1, Cons (2, nil))
val l2 = Cons (0, l1)
fun len (l) = l ? { Nil => 0 | Cons (_, xs) => 1 + len (xs) }
fun fold (l, f, accu) = l ? { Nil => accu | Cons (x, xs) => f (x, fold (xs, f, accu)) }
fun add (x, y) = x + y

val main =
  print_int (fold (l2, add, 0));
  print_string ("!\n")

OUTPUT: 
Error (execution)
  Unbound identifier add.
EXPECTED: 
3!
--------------------------------------------------------
[ OK ]   adtref.hopix

INPUT:
type list = Nil | Cons (int, cell (list))

val n = ref Nil
val l = Cons (1, ref (Cons (2, n)))
val make_cycle = (n := l)

fun take (n, l) =
  if n = 0 then 0 else l ? {
  | Nil => 0
  | Cons (x, lr) => x + take (n - 1, !lr)
  }

val main =
  print_int (take (10, l));
  print_string ("!\n")

OUTPUT: 
15!
EXPECTED: 
15!
--------------------------------------------------------
[ OK ]   adtref1.hopix

INPUT:
type list = Nil | Cons (int, cell (list))

val n = ref Nil
val l = Cons (1, ref (Cons (2, n)))
val make_cycle = (n := l)

fun take (n, l) =
  if n = 0 then 0 else l ? {
  | Nil => 0
  | Cons (x, lr) => (
      lr := l;
      x + take (n - 1, !lr)
    )
  }

val main =
  print_int (take (10, l));
  print_string ("!\n")

OUTPUT: 
10!
EXPECTED: 
10!
--------------------------------------------------------
[ OK ]   adtref2.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => !r
  | Node (l, r) => sum (l) + sum (r)
  }

val main =
  print_int (sum (node (node (leaf (1), leaf (2)), leaf (3))));
  print_string ("!\n")

OUTPUT: 
6!
EXPECTED: 
6!
--------------------------------------------------------
[ OK ]   adtref3.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => !r
  | Node (l, r) => sum (l) + sum (r)
  }

val c = ref 0
val t = node (node (Leaf (c), leaf (2)), leaf (3))

val main =
  print_int (sum (t));
  print_string ("!\n");
  c := sum (t);
  print_int (sum (t));
  print_string ("!\n")

OUTPUT: 
5!
10!
EXPECTED: 
5!
10!
--------------------------------------------------------
[ OK ]   adtref4.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => !r
  | Node (l, r) => sum (l) + sum (r)
  }

val c = ref 0
val t = node (node (Leaf (c), leaf (2)), leaf (3))

val main =
  val i = ref 10;
  while (!i > 0) {
    print_int (sum (t));
    print_string ("!\n");
    c := sum (t);
    i := !i - 1
  }

OUTPUT: 
5!
10!
15!
20!
25!
30!
35!
40!
45!
50!
EXPECTED: 
5!
10!
15!
20!
25!
30!
35!
40!
45!
50!
--------------------------------------------------------
[ OK ]   adtref5.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => !r
  | Node (l, r) => sum (l) + sum (r)
  }

val c = ref 0
val t = node (node (Leaf (c), leaf (2)), Leaf (c))

val main =
  val i = ref 10;
  while (!i > 0) {
    print_int (sum (t));
    print_string ("!\n");
    c := sum (t);
    i := !i - 1
  }

OUTPUT: 
2!
6!
14!
30!
62!
126!
254!
510!
1022!
2046!
EXPECTED: 
2!
6!
14!
30!
62!
126!
254!
510!
1022!
2046!
--------------------------------------------------------
[ OK ]   adtref6.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => (r := !r + 1; !r)
  | Node (l, r) => sum (l) + sum (r)
  }

val c = ref 0
val t = node (node (Leaf (c), leaf (1)), Leaf (c))

val main =
  val i = ref 10;
  while (!i > 0) {
    print_int (sum (t));
    print_string ("!\n");
    c := sum (t);
    i := !i - 1
  }

OUTPUT: 
5!
27!
73!
167!
357!
739!
1505!
3039!
6109!
12251!
EXPECTED: 
5!
27!
73!
167!
357!
739!
1505!
3039!
6109!
12251!
--------------------------------------------------------
[ OK ]   adtref7.hopix

INPUT:
type node = Node (cell (int), int, cell (int))

fun node (l, x, r) = Node (ref l, x, ref r)
fun sum (n, t) =
  if n < 0 then 0 else t ? {
  | Node (l, x, r) => sum (n - 1, !l) + x + sum (n - 1, !r)
  }

val u = ref 0
val t = Node (u, 1, u)
val cycle = (u := t)

val main =
  print_int (sum (10, t));
  print_string ("!\n")

OUTPUT: 
2047!
EXPECTED: 
2047!
--------------------------------------------------------
[ OK ]   arith.hopix

INPUT:
val x = 21
val y = 10 + 1
val z = x + y / 2
val t = x - y / 2
val main =
  print_int (t + z);
  print_string ("!\n")
OUTPUT: 
42!
EXPECTED: 
42!
--------------------------------------------------------
[ OK ]   arith1.hopix

INPUT:
val x = 21
val y = 10 + 1
val z = (x + y) * (x + y)
val t = x * x + 2 * x * y + y * y
val main =
  print_int (t - z);
  print_string ("!\n")
OUTPUT: 
0!
EXPECTED: 
0!
--------------------------------------------------------
[ OK ]   arith2.hopix

INPUT:
fun zero (x, y) =
 val z = (x + y) * (x + y);
 val t = x * x + 2 * x * y + y * y;
 z - t

val main =
  print_int (zero (4, 0));
  print_string ("!\n")
OUTPUT: 
0!
EXPECTED: 
0!
--------------------------------------------------------
[ OK ]   arith3.hopix

INPUT:
fun zero (x, y) =
 (x + y) * (x + y) - x * x + 2 * x * y + y * y

val main =
  print_int (zero (4, 0));
  print_string ("!\n")
OUTPUT: 
0!
EXPECTED: 
0!
--------------------------------------------------------
[ OK ]   arith4.hopix

INPUT:
val main = print_int (100 + 11)

OUTPUT: 
111EXPECTED: 
111
--------------------------------------------------------
[ OK ]   arith5.hopix

INPUT:
fun succ (x) = x + 1

fun diff_sq (x, y) = x * x - y * y

val main = print_int (succ (diff_sq (10, 2)))

OUTPUT: 
97EXPECTED: 
97
--------------------------------------------------------
[ OK ]   fact.hopix

INPUT:
fun fact (n) = if n = 0 then 1 else fact (n - 1) * n

val main = print_int (fact (6))

OUTPUT: 
720EXPECTED: 
720
--------------------------------------------------------
[ OK ]   fibo.hopix

INPUT:
fun fibo (n) = if n < 2 then n else fibo (n - 1) + fibo (n - 2)

val main = print_int (fibo (10))

OUTPUT: 
55EXPECTED: 
55
--------------------------------------------------------
[ OK ]   helloworld.hopix

INPUT:
val main = print_string ("Hello world!\n")
OUTPUT: 
Hello world!
EXPECTED: 
Hello world!
--------------------------------------------------------
[ OK ]   if0.hopix

INPUT:
val main =
  if 0 = 0 then print_string ("Foo\n") else print_string ("Bar\n")
OUTPUT: 
Foo
EXPECTED: 
Foo
--------------------------------------------------------
[ OK ]   if1.hopix

INPUT:
val main =
  if 1 = 0 then print_string ("Foo\n") else print_string ("Bar\n")
OUTPUT: 
Bar
EXPECTED: 
Bar
--------------------------------------------------------
[ OK ]   if3.hopix

INPUT:
val main =
  if 1 = 0 then print_string ("Foo\n");
  print_string ("Bar\n")
OUTPUT: 
Bar
EXPECTED: 
Bar
--------------------------------------------------------
[ OK ]   if4.hopix

INPUT:
val main =
  if 0 = 0 then print_string ("Foo\n");
  print_string ("Bar\n")
OUTPUT: 
Foo
Bar
EXPECTED: 
Foo
Bar
--------------------------------------------------------
[ OK ]   if5.hopix

INPUT:
val main =
  if 0 = 0 then
    if 1 = 0 then print_string ("Foo\n") else print_string ("Baz\n")
  else
    print_string ("Bar\n")
OUTPUT: 
Baz
EXPECTED: 
Baz
--------------------------------------------------------
[ OK ]   list.hopix

INPUT:
type list = Nil | Cons (int, list)

fun range (i, j) = if i > j then Nil else Cons (i, range (i + 1, j))

fun len (l) = l ? Nil => 0 | Cons (_, l) => 1 + len (l)

val main = print_int (len (range (1, 100)))

OUTPUT: 
100EXPECTED: 
100
--------------------------------------------------------
[ OK ]   list1.hopix

INPUT:
type list = Nil | Cons (int, list)

fun print_list (l) =
  l ? {
  | Nil => print_string ("\n")
  | Cons (h, t) =>
      print_int (h);
      print_string (" ");
      print_list (t)
  }

val main = print_list (Cons (3, Cons (5, Cons (7, Nil))))

OUTPUT: 
3 5 7 
EXPECTED: 
3 5 7
--------------------------------------------------------
[ OK ]   match.hopix

INPUT:
fun zero (x) = x ? 0 => true | _ => false

val main = if zero (13) then print_string ("true") else print_string ("false")

OUTPUT: 
falseEXPECTED: 
false
--------------------------------------------------------
[ OK ]   mutrec.hopix

INPUT:
fun even (x) = if x = 0 then true else odd (x - 1)

and odd (x) = if x = 0 then false else even (x - 1)

val main = if even (22) then print_string ("true") else print_sring ("false")

OUTPUT: 
trueEXPECTED: 
true
--------------------------------------------------------
[ OK ]   pattern0.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  a ? {
  | A => print_string ("A!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
A!
EXPECTED: 
A!
--------------------------------------------------------
[ OK ]   pattern1.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  b1 ? {
  | A => print_string ("A!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
something else!
EXPECTED: 
something else!
--------------------------------------------------------
[ OK ]   pattern10.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

fun f (x) =
  x ? {
  | A => print_string ("an A!\n")
  | B (_) => print_string ("a B\n")
  | C (_, _) => print_string ("a C!\n")
  | D (_, _) => print_string ("a D!\n")
  }

val main =
    f (a);
    f (b1);
    f (c12);
    f (dab)

OUTPUT: 
an A!
a B
a C!
a D!
EXPECTED: 
an A!
a B
a C!
a D!
--------------------------------------------------------
[ KO ]   -->  pattern11.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)
type list = Nil | Cons (int, list)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

fun f (x) =
  x ? {
  | A => print_string ("an A!\n")
  | B (_) => print_string ("a B\n")
  | C (_, _) => print_string ("a C!\n")
  | D (_, _) => print_string ("a D!\n")
  }

val n = Nil
fun c (x, xs) = Cons (x, xs)

fun iter (f, l) =
  l ? {
  | Cons (x, Nil) => f (x)
  | Cons (x, xs) => (f (x); iter (f, xs))
  }

val l = c (a, c (b1, c (c12, c (dab, n))))

val main = iter (f, l)

OUTPUT: 
Error (execution)
  Unbound identifier f.
EXPECTED: 
an A!
a B
a C!
a D!
--------------------------------------------------------
[ KO ]   -->  pattern12.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)
type list = Nil | Cons (int, list)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

fun f (x) =
  x ? {
  | A => print_string ("an A!\n")
  | B (_) => print_string ("a B\n")
  | C (_, _) => print_string ("a C!\n")
  | D (_, _) => print_string ("a D!\n")
  }

val n = Nil
fun c (x, xs) = Cons (x, xs)

fun iter (f, l) =
  l ? {
  | Cons (x, xs) => (f (x); iter (f, xs))
  | Cons (x, Nil) => f (x)
  | Nil => print_string ("Stop!\n")
  }

val l = c (a, c (b1, c (c12, c (dab, n))))

val main = iter (f, l)

OUTPUT: 
Error (execution)
  Unbound identifier f.
EXPECTED: 
an A!
a B
a C!
a D!
Stop!
--------------------------------------------------------
[ KO ]   -->  pattern13.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)
type list = Nil | Cons (int, list)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

fun f (x) =
  x ? {
  | A & A => print_string ("an A!\n")
  | B (_) & x => print_string ("a B\n")
  | C (_, _) & _ => print_string ("a C!\n")
  | D (_, _) & (D (_, _) | D (_, _)) => print_string ("a D!\n")
  }

val n = Nil
fun c (x, xs) = Cons (x, xs)

fun iter (f, l) =
  l ? {
  | Cons (x, xs) => (f (x); iter (f, xs))
  | Cons (x, Nil) => f (x)
  | Nil => print_string ("Stop!\n")
  }

val l = c (a, c (b1, c (c12, c (dab, n))))

val main = iter (f, l)

OUTPUT: 
Error (execution)
  Unbound identifier f.
EXPECTED: 
an A!
a B
a C!
a D!
Stop!
--------------------------------------------------------
[ OK ]   pattern2.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  b1 ? {
  | B (x) => (
    print_string ("B of ");
    print_int (x);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
B of 1!
EXPECTED: 
B of 1!
--------------------------------------------------------
[ OK ]   pattern3.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  (B (2)) ? {
  | B (x) => (
    print_string ("B of ");
    print_int (x);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
B of 2!
EXPECTED: 
B of 2!
--------------------------------------------------------
[ OK ]   pattern4.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  a ? {
  | B (x) => (
    print_string ("B of ");
    print_int (x);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
something else!
EXPECTED: 
something else!
--------------------------------------------------------
[ OK ]   pattern5.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  c12 ? {
  | C (x, y) => (
    print_string ("C of ");
    print_int (x);
    print_string (" and ");
    print_int (y);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
C of 1 and 2!
EXPECTED: 
C of 1 and 2!
--------------------------------------------------------
[ OK ]   pattern6.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  dab ? {
  | D (A, B (x)) => (
    print_string ("D with a B of ");
    print_int (x);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
D with a B of 1!
EXPECTED: 
D with a B of 1!
--------------------------------------------------------
[ OK ]   pattern7.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  a ? {
  | A | B (_) =>
    print_string ("An A or a B!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
An A or a B!
EXPECTED: 
An A or a B!
--------------------------------------------------------
[ OK ]   pattern8.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  b1 ? {
  | A | B (_) =>
    print_string ("An A or a B!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
An A or a B!
EXPECTED: 
An A or a B!
--------------------------------------------------------
[ OK ]   pattern9.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  dab ? {
  | A | B (_) =>
    print_string ("An A or a B!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
something else!
EXPECTED: 
something else!
--------------------------------------------------------
[ OK ]   ref1.hopix

INPUT:
val main = print_int (!ref 42)

OUTPUT: 
42EXPECTED: 
42
--------------------------------------------------------
[ KO ]   -->  singleton.hopix

INPUT:
type list = Nil | Cons (int, list)

fun singleton (l) = l ? Cons (_, Nil) => true | _ => false

val main =
  if singleton (Nil) then print_string ("true") else print_string ("false")

OUTPUT: 

Invalid_argument("index out of bounds")
EXPECTED: 
false
--------------------------------------------------------
[ OK ]   sum.hopix

INPUT:
fun sum (x, y, z, t, u) =
  if x = 0 then y + z + t + u else 1 + sum (x - 1, y, z, t, u)

val main = print_int (sum (1, 2, 3, 4, 5))

OUTPUT: 
15EXPECTED: 
15
--------------------------------------------------------
GOOD: 42 / 47

BAD:  0 / 0
make[1]: Leaving directory '/home/opam/source/flap/tests-flap/hopix/fopix/good'
make[1]: Entering directory '/home/opam/source/flap/tests-flap/hopix/hobix/good'
========================================================
In hobix/good
[ OK ]   adt.hopix

INPUT:
type list = Nil | Cons (int, list)

val nil = Nil
val l1 = Cons (1, Cons (2, nil))
val l2 = Cons (0, l1)
val main =
  l2 ? {
  | Nil => print_string ("Wrong!\n")
  | Cons (x, _) => print_int (x)
  };
  print_string ("!\n")

OUTPUT: 
0!
EXPECTED: 
0!
--------------------------------------------------------
[ OK ]   adt1.hopix

INPUT:
type list = Nil | Cons (int, list)

val nil = Nil
val l1 = Cons (1, Cons (2, nil))
val l2 = Cons (0, l1)
val main =
  l2 ? {
  | Nil => print_string ("Wrong!\n")
  | Cons (x, xs) =>
    xs ? {
    | Nil => print_string ("Wrong!\n")
    | Cons (y, _) => print_int (y)
    }
  };
  print_string ("!\n")

OUTPUT: 
1!
EXPECTED: 
1!
--------------------------------------------------------
[ OK ]   adt2.hopix

INPUT:
type list = Nil | Cons (int, list)

val nil = Nil
val l1 = Cons (1, Cons (2, nil))
val l2 = Cons (0, l1)
fun len (l) = l ? { Nil => 0 | Cons (_, xs) => 1 + len (xs) }

val main =
  print_int (len (l1));
  print_string ("!\n")

OUTPUT: 
2!
EXPECTED: 
2!
--------------------------------------------------------
[ OK ]   adt3.hopix

INPUT:
type list = Nil | Cons (int, list)

val nil = Nil
val l1 = Cons (1, Cons (2, nil))
val l2 = Cons (0, l1)
fun len (l) = l ? { Nil => 0 | Cons (_, xs) => 1 + len (xs) }
fun fold (l, f, accu) = l ? { Nil => accu | Cons (x, xs) => f (x, fold (xs, f, accu)) }
fun add (x, y) = x + y

val main =
  print_int (fold (l2, add, 0));
  print_string ("!\n")

OUTPUT: 
3!
EXPECTED: 
3!
--------------------------------------------------------
[ OK ]   adtref.hopix

INPUT:
type list = Nil | Cons (int, cell (list))

val n = ref Nil
val l = Cons (1, ref (Cons (2, n)))
val make_cycle = (n := l)

fun take (n, l) =
  if n = 0 then 0 else l ? {
  | Nil => 0
  | Cons (x, lr) => x + take (n - 1, !lr)
  }

val main =
  print_int (take (10, l));
  print_string ("!\n")

OUTPUT: 
15!
EXPECTED: 
15!
--------------------------------------------------------
[ OK ]   adtref1.hopix

INPUT:
type list = Nil | Cons (int, cell (list))

val n = ref Nil
val l = Cons (1, ref (Cons (2, n)))
val make_cycle = (n := l)

fun take (n, l) =
  if n = 0 then 0 else l ? {
  | Nil => 0
  | Cons (x, lr) => (
      lr := l;
      x + take (n - 1, !lr)
    )
  }

val main =
  print_int (take (10, l));
  print_string ("!\n")

OUTPUT: 
10!
EXPECTED: 
10!
--------------------------------------------------------
[ OK ]   adtref2.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => !r
  | Node (l, r) => sum (l) + sum (r)
  }

val main =
  print_int (sum (node (node (leaf (1), leaf (2)), leaf (3))));
  print_string ("!\n")

OUTPUT: 
6!
EXPECTED: 
6!
--------------------------------------------------------
[ OK ]   adtref3.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => !r
  | Node (l, r) => sum (l) + sum (r)
  }

val c = ref 0
val t = node (node (Leaf (c), leaf (2)), leaf (3))

val main =
  print_int (sum (t));
  print_string ("!\n");
  c := sum (t);
  print_int (sum (t));
  print_string ("!\n")

OUTPUT: 
5!
10!
EXPECTED: 
5!
10!
--------------------------------------------------------
[ OK ]   adtref4.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => !r
  | Node (l, r) => sum (l) + sum (r)
  }

val c = ref 0
val t = node (node (Leaf (c), leaf (2)), leaf (3))

val main =
  val i = ref 10;
  while (!i > 0) {
    print_int (sum (t));
    print_string ("!\n");
    c := sum (t);
    i := !i - 1
  }

OUTPUT: 
5!
10!
15!
20!
25!
30!
35!
40!
45!
50!
EXPECTED: 
5!
10!
15!
20!
25!
30!
35!
40!
45!
50!
--------------------------------------------------------
[ OK ]   adtref5.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => !r
  | Node (l, r) => sum (l) + sum (r)
  }

val c = ref 0
val t = node (node (Leaf (c), leaf (2)), Leaf (c))

val main =
  val i = ref 10;
  while (!i > 0) {
    print_int (sum (t));
    print_string ("!\n");
    c := sum (t);
    i := !i - 1
  }

OUTPUT: 
2!
6!
14!
30!
62!
126!
254!
510!
1022!
2046!
EXPECTED: 
2!
6!
14!
30!
62!
126!
254!
510!
1022!
2046!
--------------------------------------------------------
[ OK ]   adtref6.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => (r := !r + 1; !r)
  | Node (l, r) => sum (l) + sum (r)
  }

val c = ref 0
val t = node (node (Leaf (c), leaf (1)), Leaf (c))

val main =
  val i = ref 10;
  while (!i > 0) {
    print_int (sum (t));
    print_string ("!\n");
    c := sum (t);
    i := !i - 1
  }

OUTPUT: 
5!
27!
73!
167!
357!
739!
1505!
3039!
6109!
12251!
EXPECTED: 
5!
27!
73!
167!
357!
739!
1505!
3039!
6109!
12251!
--------------------------------------------------------
[ OK ]   adtref7.hopix

INPUT:
type node = Node (cell (int), int, cell (int))

fun node (l, x, r) = Node (ref l, x, ref r)
fun sum (n, t) =
  if n < 0 then 0 else t ? {
  | Node (l, x, r) => sum (n - 1, !l) + x + sum (n - 1, !r)
  }

val u = ref 0
val t = Node (u, 1, u)
val cycle = (u := t)

val main =
  print_int (sum (10, t));
  print_string ("!\n")

OUTPUT: 
2047!
EXPECTED: 
2047!
--------------------------------------------------------
[ OK ]   arith.hopix

INPUT:
val x = 21
val y = 10 + 1
val z = x + y / 2
val t = x - y / 2
val main =
  print_int (t + z);
  print_string ("!\n")
OUTPUT: 
42!
EXPECTED: 
42!
--------------------------------------------------------
[ OK ]   arith1.hopix

INPUT:
val x = 21
val y = 10 + 1
val z = (x + y) * (x + y)
val t = x * x + 2 * x * y + y * y
val main =
  print_int (t - z);
  print_string ("!\n")
OUTPUT: 
0!
EXPECTED: 
0!
--------------------------------------------------------
[ OK ]   arith2.hopix

INPUT:
fun zero (x, y) =
 val z = (x + y) * (x + y);
 val t = x * x + 2 * x * y + y * y;
 z - t

val main =
  print_int (zero (4, 0));
  print_string ("!\n")
OUTPUT: 
0!
EXPECTED: 
0!
--------------------------------------------------------
[ OK ]   arith3.hopix

INPUT:
fun zero (x, y) =
 (x + y) * (x + y) - x * x + 2 * x * y + y * y

val main =
  print_int (zero (4, 0));
  print_string ("!\n")
OUTPUT: 
0!
EXPECTED: 
0!
--------------------------------------------------------
[ OK ]   arith4.hopix

INPUT:
val main = print_int (100 + 11)

OUTPUT: 
111EXPECTED: 
111
--------------------------------------------------------
[ OK ]   arith5.hopix

INPUT:
fun succ (x) = x + 1

fun diff_sq (x, y) = x * x - y * y

val main = print_int (succ (diff_sq (10, 2)))

OUTPUT: 
97EXPECTED: 
97
--------------------------------------------------------
[ OK ]   fact.hopix

INPUT:
fun fact (n) = if n = 0 then 1 else fact (n - 1) * n

val main = print_int (fact (6))

OUTPUT: 
720EXPECTED: 
720
--------------------------------------------------------
[ OK ]   fibo.hopix

INPUT:
fun fibo (n) = if n < 2 then n else fibo (n - 1) + fibo (n - 2)

val main = print_int (fibo (10))

OUTPUT: 
55EXPECTED: 
55
--------------------------------------------------------
[ OK ]   helloworld.hopix

INPUT:
val main = print_string ("Hello world!\n")
OUTPUT: 
Hello world!
EXPECTED: 
Hello world!
--------------------------------------------------------
[ OK ]   if0.hopix

INPUT:
val main =
  if 0 = 0 then print_string ("Foo\n") else print_string ("Bar\n")
OUTPUT: 
Foo
EXPECTED: 
Foo
--------------------------------------------------------
[ OK ]   if1.hopix

INPUT:
val main =
  if 1 = 0 then print_string ("Foo\n") else print_string ("Bar\n")
OUTPUT: 
Bar
EXPECTED: 
Bar
--------------------------------------------------------
[ OK ]   if3.hopix

INPUT:
val main =
  if 1 = 0 then print_string ("Foo\n");
  print_string ("Bar\n")
OUTPUT: 
Bar
EXPECTED: 
Bar
--------------------------------------------------------
[ OK ]   if4.hopix

INPUT:
val main =
  if 0 = 0 then print_string ("Foo\n");
  print_string ("Bar\n")
OUTPUT: 
Foo
Bar
EXPECTED: 
Foo
Bar
--------------------------------------------------------
[ OK ]   if5.hopix

INPUT:
val main =
  if 0 = 0 then
    if 1 = 0 then print_string ("Foo\n") else print_string ("Baz\n")
  else
    print_string ("Bar\n")
OUTPUT: 
Baz
EXPECTED: 
Baz
--------------------------------------------------------
[ OK ]   list.hopix

INPUT:
type list = Nil | Cons (int, list)

fun range (i, j) = if i > j then Nil else Cons (i, range (i + 1, j))

fun len (l) = l ? Nil => 0 | Cons (_, l) => 1 + len (l)

val main = print_int (len (range (1, 100)))

OUTPUT: 
100EXPECTED: 
100
--------------------------------------------------------
[ OK ]   list1.hopix

INPUT:
type list = Nil | Cons (int, list)

fun print_list (l) =
  l ? {
  | Nil => print_string ("\n")
  | Cons (h, t) =>
      print_int (h);
      print_string (" ");
      print_list (t)
  }

val main = print_list (Cons (3, Cons (5, Cons (7, Nil))))

OUTPUT: 
3 5 7 
EXPECTED: 
3 5 7
--------------------------------------------------------
[ OK ]   match.hopix

INPUT:
fun zero (x) = x ? 0 => true | _ => false

val main = if zero (13) then print_string ("true") else print_string ("false")

OUTPUT: 
falseEXPECTED: 
false
--------------------------------------------------------
[ OK ]   mutrec.hopix

INPUT:
fun even (x) = if x = 0 then true else odd (x - 1)

and odd (x) = if x = 0 then false else even (x - 1)

val main = if even (22) then print_string ("true") else print_sring ("false")

OUTPUT: 
trueEXPECTED: 
true
--------------------------------------------------------
[ OK ]   pattern0.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  a ? {
  | A => print_string ("A!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
A!
EXPECTED: 
A!
--------------------------------------------------------
[ OK ]   pattern1.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  b1 ? {
  | A => print_string ("A!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
something else!
EXPECTED: 
something else!
--------------------------------------------------------
[ OK ]   pattern10.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

fun f (x) =
  x ? {
  | A => print_string ("an A!\n")
  | B (_) => print_string ("a B\n")
  | C (_, _) => print_string ("a C!\n")
  | D (_, _) => print_string ("a D!\n")
  }

val main =
    f (a);
    f (b1);
    f (c12);
    f (dab)

OUTPUT: 
an A!
a B
a C!
a D!
EXPECTED: 
an A!
a B
a C!
a D!
--------------------------------------------------------
[ OK ]   pattern11.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)
type list = Nil | Cons (int, list)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

fun f (x) =
  x ? {
  | A => print_string ("an A!\n")
  | B (_) => print_string ("a B\n")
  | C (_, _) => print_string ("a C!\n")
  | D (_, _) => print_string ("a D!\n")
  }

val n = Nil
fun c (x, xs) = Cons (x, xs)

fun iter (f, l) =
  l ? {
  | Cons (x, Nil) => f (x)
  | Cons (x, xs) => (f (x); iter (f, xs))
  }

val l = c (a, c (b1, c (c12, c (dab, n))))

val main = iter (f, l)

OUTPUT: 
an A!
a B
a C!
a D!
EXPECTED: 
an A!
a B
a C!
a D!
--------------------------------------------------------
[ OK ]   pattern12.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)
type list = Nil | Cons (int, list)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

fun f (x) =
  x ? {
  | A => print_string ("an A!\n")
  | B (_) => print_string ("a B\n")
  | C (_, _) => print_string ("a C!\n")
  | D (_, _) => print_string ("a D!\n")
  }

val n = Nil
fun c (x, xs) = Cons (x, xs)

fun iter (f, l) =
  l ? {
  | Cons (x, xs) => (f (x); iter (f, xs))
  | Cons (x, Nil) => f (x)
  | Nil => print_string ("Stop!\n")
  }

val l = c (a, c (b1, c (c12, c (dab, n))))

val main = iter (f, l)

OUTPUT: 
an A!
a B
a C!
a D!
Stop!
EXPECTED: 
an A!
a B
a C!
a D!
Stop!
--------------------------------------------------------
[ OK ]   pattern13.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)
type list = Nil | Cons (int, list)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

fun f (x) =
  x ? {
  | A & A => print_string ("an A!\n")
  | B (_) & x => print_string ("a B\n")
  | C (_, _) & _ => print_string ("a C!\n")
  | D (_, _) & (D (_, _) | D (_, _)) => print_string ("a D!\n")
  }

val n = Nil
fun c (x, xs) = Cons (x, xs)

fun iter (f, l) =
  l ? {
  | Cons (x, xs) => (f (x); iter (f, xs))
  | Cons (x, Nil) => f (x)
  | Nil => print_string ("Stop!\n")
  }

val l = c (a, c (b1, c (c12, c (dab, n))))

val main = iter (f, l)

OUTPUT: 
an A!
a B
a C!
a D!
Stop!
EXPECTED: 
an A!
a B
a C!
a D!
Stop!
--------------------------------------------------------
[ OK ]   pattern2.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  b1 ? {
  | B (x) => (
    print_string ("B of ");
    print_int (x);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
B of 1!
EXPECTED: 
B of 1!
--------------------------------------------------------
[ OK ]   pattern3.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  (B (2)) ? {
  | B (x) => (
    print_string ("B of ");
    print_int (x);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
B of 2!
EXPECTED: 
B of 2!
--------------------------------------------------------
[ OK ]   pattern4.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  a ? {
  | B (x) => (
    print_string ("B of ");
    print_int (x);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
something else!
EXPECTED: 
something else!
--------------------------------------------------------
[ OK ]   pattern5.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  c12 ? {
  | C (x, y) => (
    print_string ("C of ");
    print_int (x);
    print_string (" and ");
    print_int (y);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
C of 1 and 2!
EXPECTED: 
C of 1 and 2!
--------------------------------------------------------
[ OK ]   pattern6.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  dab ? {
  | D (A, B (x)) => (
    print_string ("D with a B of ");
    print_int (x);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
D with a B of 1!
EXPECTED: 
D with a B of 1!
--------------------------------------------------------
[ OK ]   pattern7.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  a ? {
  | A | B (_) =>
    print_string ("An A or a B!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
An A or a B!
EXPECTED: 
An A or a B!
--------------------------------------------------------
[ OK ]   pattern8.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  b1 ? {
  | A | B (_) =>
    print_string ("An A or a B!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
An A or a B!
EXPECTED: 
An A or a B!
--------------------------------------------------------
[ OK ]   pattern9.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  dab ? {
  | A | B (_) =>
    print_string ("An A or a B!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 
something else!
EXPECTED: 
something else!
--------------------------------------------------------
[ OK ]   ref1.hopix

INPUT:
val main = print_int (!ref 42)

OUTPUT: 
42EXPECTED: 
42
--------------------------------------------------------
[ OK ]   singleton.hopix

INPUT:
type list = Nil | Cons (int, list)

fun singleton (l) = l ? Cons (_, Nil) => true | _ => false

val main =
  if singleton (Nil) then print_string ("true") else print_string ("false")

OUTPUT: 
falseEXPECTED: 
false
--------------------------------------------------------
[ OK ]   sum.hopix

INPUT:
fun sum (x, y, z, t, u) =
  if x = 0 then y + z + t + u else 1 + sum (x - 1, y, z, t, u)

val main = print_int (sum (1, 2, 3, 4, 5))

OUTPUT: 
15EXPECTED: 
15
--------------------------------------------------------
GOOD: 47 / 47

BAD:  0 / 0
make[1]: Leaving directory '/home/opam/source/flap/tests-flap/hopix/hobix/good'
make[1]: Entering directory '/home/opam/source/flap/tests-flap/hopix/retrolix/good'
========================================================
In retrolix/good
[ KO ]   -->  adt.hopix

INPUT:
type list = Nil | Cons (int, list)

val nil = Nil
val l1 = Cons (1, Cons (2, nil))
val l2 = Cons (0, l1)
val main =
  l2 ? {
  | Nil => print_string ("Wrong!\n")
  | Cons (x, _) => print_int (x)
  };
  print_string ("!\n")

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
0!
--------------------------------------------------------
[ KO ]   -->  adt1.hopix

INPUT:
type list = Nil | Cons (int, list)

val nil = Nil
val l1 = Cons (1, Cons (2, nil))
val l2 = Cons (0, l1)
val main =
  l2 ? {
  | Nil => print_string ("Wrong!\n")
  | Cons (x, xs) =>
    xs ? {
    | Nil => print_string ("Wrong!\n")
    | Cons (y, _) => print_int (y)
    }
  };
  print_string ("!\n")

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
1!
--------------------------------------------------------
[ KO ]   -->  adt2.hopix

INPUT:
type list = Nil | Cons (int, list)

val nil = Nil
val l1 = Cons (1, Cons (2, nil))
val l2 = Cons (0, l1)
fun len (l) = l ? { Nil => 0 | Cons (_, xs) => 1 + len (xs) }

val main =
  print_int (len (l1));
  print_string ("!\n")

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
2!
--------------------------------------------------------
[ KO ]   -->  adt3.hopix

INPUT:
type list = Nil | Cons (int, list)

val nil = Nil
val l1 = Cons (1, Cons (2, nil))
val l2 = Cons (0, l1)
fun len (l) = l ? { Nil => 0 | Cons (_, xs) => 1 + len (xs) }
fun fold (l, f, accu) = l ? { Nil => accu | Cons (x, xs) => f (x, fold (xs, f, accu)) }
fun add (x, y) = x + y

val main =
  print_int (fold (l2, add, 0));
  print_string ("!\n")

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
3!
--------------------------------------------------------
[ KO ]   -->  adtref.hopix

INPUT:
type list = Nil | Cons (int, cell (list))

val n = ref Nil
val l = Cons (1, ref (Cons (2, n)))
val make_cycle = (n := l)

fun take (n, l) =
  if n = 0 then 0 else l ? {
  | Nil => 0
  | Cons (x, lr) => x + take (n - 1, !lr)
  }

val main =
  print_int (take (10, l));
  print_string ("!\n")

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
15!
--------------------------------------------------------
[ KO ]   -->  adtref1.hopix

INPUT:
type list = Nil | Cons (int, cell (list))

val n = ref Nil
val l = Cons (1, ref (Cons (2, n)))
val make_cycle = (n := l)

fun take (n, l) =
  if n = 0 then 0 else l ? {
  | Nil => 0
  | Cons (x, lr) => (
      lr := l;
      x + take (n - 1, !lr)
    )
  }

val main =
  print_int (take (10, l));
  print_string ("!\n")

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
10!
--------------------------------------------------------
[ KO ]   -->  adtref2.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => !r
  | Node (l, r) => sum (l) + sum (r)
  }

val main =
  print_int (sum (node (node (leaf (1), leaf (2)), leaf (3))));
  print_string ("!\n")

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
6!
--------------------------------------------------------
[ KO ]   -->  adtref3.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => !r
  | Node (l, r) => sum (l) + sum (r)
  }

val c = ref 0
val t = node (node (Leaf (c), leaf (2)), leaf (3))

val main =
  print_int (sum (t));
  print_string ("!\n");
  c := sum (t);
  print_int (sum (t));
  print_string ("!\n")

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
5!
10!
--------------------------------------------------------
[ KO ]   -->  adtref4.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => !r
  | Node (l, r) => sum (l) + sum (r)
  }

val c = ref 0
val t = node (node (Leaf (c), leaf (2)), leaf (3))

val main =
  val i = ref 10;
  while (!i > 0) {
    print_int (sum (t));
    print_string ("!\n");
    c := sum (t);
    i := !i - 1
  }

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
5!
10!
15!
20!
25!
30!
35!
40!
45!
50!
--------------------------------------------------------
[ KO ]   -->  adtref5.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => !r
  | Node (l, r) => sum (l) + sum (r)
  }

val c = ref 0
val t = node (node (Leaf (c), leaf (2)), Leaf (c))

val main =
  val i = ref 10;
  while (!i > 0) {
    print_int (sum (t));
    print_string ("!\n");
    c := sum (t);
    i := !i - 1
  }

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
2!
6!
14!
30!
62!
126!
254!
510!
1022!
2046!
--------------------------------------------------------
[ KO ]   -->  adtref6.hopix

INPUT:
type tree = Leaf (cell (int)) | Node (tree, tree)

fun leaf (x) = Leaf (ref x)
fun node (l, r) = Node (l, r)
fun sum (t) = t ? {
  | Leaf (r) => (r := !r + 1; !r)
  | Node (l, r) => sum (l) + sum (r)
  }

val c = ref 0
val t = node (node (Leaf (c), leaf (1)), Leaf (c))

val main =
  val i = ref 10;
  while (!i > 0) {
    print_int (sum (t));
    print_string ("!\n");
    c := sum (t);
    i := !i - 1
  }

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
5!
27!
73!
167!
357!
739!
1505!
3039!
6109!
12251!
--------------------------------------------------------
[ KO ]   -->  adtref7.hopix

INPUT:
type node = Node (cell (int), int, cell (int))

fun node (l, x, r) = Node (ref l, x, ref r)
fun sum (n, t) =
  if n < 0 then 0 else t ? {
  | Node (l, x, r) => sum (n - 1, !l) + x + sum (n - 1, !r)
  }

val u = ref 0
val t = Node (u, 1, u)
val cycle = (u := t)

val main =
  print_int (sum (10, t));
  print_string ("!\n")

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
2047!
--------------------------------------------------------
[ KO ]   -->  arith.hopix

INPUT:
val x = 21
val y = 10 + 1
val z = x + y / 2
val t = x - y / 2
val main =
  print_int (t + z);
  print_string ("!\n")
OUTPUT: 

Failure("NoSuchFunction: print_int")
EXPECTED: 
42!
--------------------------------------------------------
[ KO ]   -->  arith1.hopix

INPUT:
val x = 21
val y = 10 + 1
val z = (x + y) * (x + y)
val t = x * x + 2 * x * y + y * y
val main =
  print_int (t - z);
  print_string ("!\n")
OUTPUT: 

Failure("NoSuchFunction: print_int")
EXPECTED: 
0!
--------------------------------------------------------
[ KO ]   -->  arith2.hopix

INPUT:
fun zero (x, y) =
 val z = (x + y) * (x + y);
 val t = x * x + 2 * x * y + y * y;
 z - t

val main =
  print_int (zero (4, 0));
  print_string ("!\n")
OUTPUT: 

Failure("NoSuchFunction: print_int")
EXPECTED: 
0!
--------------------------------------------------------
[ KO ]   -->  arith3.hopix

INPUT:
fun zero (x, y) =
 (x + y) * (x + y) - x * x + 2 * x * y + y * y

val main =
  print_int (zero (4, 0));
  print_string ("!\n")
OUTPUT: 

Failure("NoSuchFunction: print_int")
EXPECTED: 
0!
--------------------------------------------------------
[ KO ]   -->  arith4.hopix

INPUT:
val main = print_int (100 + 11)

OUTPUT: 

Failure("NoSuchFunction: print_int")
EXPECTED: 
111
--------------------------------------------------------
[ KO ]   -->  arith5.hopix

INPUT:
fun succ (x) = x + 1

fun diff_sq (x, y) = x * x - y * y

val main = print_int (succ (diff_sq (10, 2)))

OUTPUT: 

Failure("NoSuchFunction: print_int")
EXPECTED: 
97
--------------------------------------------------------
[ KO ]   -->  fact.hopix

INPUT:
fun fact (n) = if n = 0 then 1 else fact (n - 1) * n

val main = print_int (fact (6))

OUTPUT: 

Failure("NoSuchFunction: print_int")
EXPECTED: 
720
--------------------------------------------------------
[ KO ]   -->  fibo.hopix

INPUT:
fun fibo (n) = if n < 2 then n else fibo (n - 1) + fibo (n - 2)

val main = print_int (fibo (10))

OUTPUT: 

Failure("NoSuchFunction: print_int")
EXPECTED: 
55
--------------------------------------------------------
[ KO ]   -->  helloworld.hopix

INPUT:
val main = print_string ("Hello world!\n")
OUTPUT: 

Failure("NoSuchFunction: print_string")
EXPECTED: 
Hello world!
--------------------------------------------------------
[ KO ]   -->  if0.hopix

INPUT:
val main =
  if 0 = 0 then print_string ("Foo\n") else print_string ("Bar\n")
OUTPUT: 

Failure("NoSuchFunction: print_string")
EXPECTED: 
Foo
--------------------------------------------------------
[ KO ]   -->  if1.hopix

INPUT:
val main =
  if 1 = 0 then print_string ("Foo\n") else print_string ("Bar\n")
OUTPUT: 

Failure("NoSuchFunction: print_string")
EXPECTED: 
Bar
--------------------------------------------------------
[ KO ]   -->  if3.hopix

INPUT:
val main =
  if 1 = 0 then print_string ("Foo\n");
  print_string ("Bar\n")
OUTPUT: 

Failure("NoSuchFunction: print_string")
EXPECTED: 
Bar
--------------------------------------------------------
[ KO ]   -->  if4.hopix

INPUT:
val main =
  if 0 = 0 then print_string ("Foo\n");
  print_string ("Bar\n")
OUTPUT: 

Failure("NoSuchFunction: print_string")
EXPECTED: 
Foo
Bar
--------------------------------------------------------
[ KO ]   -->  if5.hopix

INPUT:
val main =
  if 0 = 0 then
    if 1 = 0 then print_string ("Foo\n") else print_string ("Baz\n")
  else
    print_string ("Bar\n")
OUTPUT: 

Failure("NoSuchFunction: print_string")
EXPECTED: 
Baz
--------------------------------------------------------
[ KO ]   -->  list.hopix

INPUT:
type list = Nil | Cons (int, list)

fun range (i, j) = if i > j then Nil else Cons (i, range (i + 1, j))

fun len (l) = l ? Nil => 0 | Cons (_, l) => 1 + len (l)

val main = print_int (len (range (1, 100)))

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
100
--------------------------------------------------------
[ KO ]   -->  list1.hopix

INPUT:
type list = Nil | Cons (int, list)

fun print_list (l) =
  l ? {
  | Nil => print_string ("\n")
  | Cons (h, t) =>
      print_int (h);
      print_string (" ");
      print_list (t)
  }

val main = print_list (Cons (3, Cons (5, Cons (7, Nil))))

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
3 5 7
--------------------------------------------------------
[ KO ]   -->  match.hopix

INPUT:
fun zero (x) = x ? 0 => true | _ => false

val main = if zero (13) then print_string ("true") else print_string ("false")

OUTPUT: 

Failure("NoSuchFunction: print_string")
EXPECTED: 
false
--------------------------------------------------------
[ KO ]   -->  mutrec.hopix

INPUT:
fun even (x) = if x = 0 then true else odd (x - 1)

and odd (x) = if x = 0 then false else even (x - 1)

val main = if even (22) then print_string ("true") else print_sring ("false")

OUTPUT: 

Failure("NoSuchFunction: print_string")
EXPECTED: 
true
--------------------------------------------------------
[ KO ]   -->  pattern0.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  a ? {
  | A => print_string ("A!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
A!
--------------------------------------------------------
[ KO ]   -->  pattern1.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  b1 ? {
  | A => print_string ("A!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
something else!
--------------------------------------------------------
[ KO ]   -->  pattern10.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

fun f (x) =
  x ? {
  | A => print_string ("an A!\n")
  | B (_) => print_string ("a B\n")
  | C (_, _) => print_string ("a C!\n")
  | D (_, _) => print_string ("a D!\n")
  }

val main =
    f (a);
    f (b1);
    f (c12);
    f (dab)

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
an A!
a B
a C!
a D!
--------------------------------------------------------
[ KO ]   -->  pattern11.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)
type list = Nil | Cons (int, list)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

fun f (x) =
  x ? {
  | A => print_string ("an A!\n")
  | B (_) => print_string ("a B\n")
  | C (_, _) => print_string ("a C!\n")
  | D (_, _) => print_string ("a D!\n")
  }

val n = Nil
fun c (x, xs) = Cons (x, xs)

fun iter (f, l) =
  l ? {
  | Cons (x, Nil) => f (x)
  | Cons (x, xs) => (f (x); iter (f, xs))
  }

val l = c (a, c (b1, c (c12, c (dab, n))))

val main = iter (f, l)

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
an A!
a B
a C!
a D!
--------------------------------------------------------
[ KO ]   -->  pattern12.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)
type list = Nil | Cons (int, list)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

fun f (x) =
  x ? {
  | A => print_string ("an A!\n")
  | B (_) => print_string ("a B\n")
  | C (_, _) => print_string ("a C!\n")
  | D (_, _) => print_string ("a D!\n")
  }

val n = Nil
fun c (x, xs) = Cons (x, xs)

fun iter (f, l) =
  l ? {
  | Cons (x, xs) => (f (x); iter (f, xs))
  | Cons (x, Nil) => f (x)
  | Nil => print_string ("Stop!\n")
  }

val l = c (a, c (b1, c (c12, c (dab, n))))

val main = iter (f, l)

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
an A!
a B
a C!
a D!
Stop!
--------------------------------------------------------
[ KO ]   -->  pattern13.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)
type list = Nil | Cons (int, list)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

fun f (x) =
  x ? {
  | A & A => print_string ("an A!\n")
  | B (_) & x => print_string ("a B\n")
  | C (_, _) & _ => print_string ("a C!\n")
  | D (_, _) & (D (_, _) | D (_, _)) => print_string ("a D!\n")
  }

val n = Nil
fun c (x, xs) = Cons (x, xs)

fun iter (f, l) =
  l ? {
  | Cons (x, xs) => (f (x); iter (f, xs))
  | Cons (x, Nil) => f (x)
  | Nil => print_string ("Stop!\n")
  }

val l = c (a, c (b1, c (c12, c (dab, n))))

val main = iter (f, l)

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
an A!
a B
a C!
a D!
Stop!
--------------------------------------------------------
[ KO ]   -->  pattern2.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  b1 ? {
  | B (x) => (
    print_string ("B of ");
    print_int (x);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
B of 1!
--------------------------------------------------------
[ KO ]   -->  pattern3.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  (B (2)) ? {
  | B (x) => (
    print_string ("B of ");
    print_int (x);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
B of 2!
--------------------------------------------------------
[ KO ]   -->  pattern4.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  a ? {
  | B (x) => (
    print_string ("B of ");
    print_int (x);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
something else!
--------------------------------------------------------
[ KO ]   -->  pattern5.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  c12 ? {
  | C (x, y) => (
    print_string ("C of ");
    print_int (x);
    print_string (" and ");
    print_int (y);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
C of 1 and 2!
--------------------------------------------------------
[ KO ]   -->  pattern6.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  dab ? {
  | D (A, B (x)) => (
    print_string ("D with a B of ");
    print_int (x);
    print_string ("!\n")
  )
  | _ => print_string ("something else!\n")
  }

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
D with a B of 1!
--------------------------------------------------------
[ KO ]   -->  pattern7.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  a ? {
  | A | B (_) =>
    print_string ("An A or a B!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
An A or a B!
--------------------------------------------------------
[ KO ]   -->  pattern8.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  b1 ? {
  | A | B (_) =>
    print_string ("An A or a B!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
An A or a B!
--------------------------------------------------------
[ KO ]   -->  pattern9.hopix

INPUT:
type t = A | B (int) | C (int, int) | D (t, t)

val a = A
val b1 = B (1)
val c12 = C (1, 2)
val dab = D (a, b1)

val main =
  dab ? {
  | A | B (_) =>
    print_string ("An A or a B!\n")
  | _ => print_string ("something else!\n")
  }

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
something else!
--------------------------------------------------------
[ KO ]   -->  ref1.hopix

INPUT:
val main = print_int (!ref 42)

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
42
--------------------------------------------------------
[ KO ]   -->  singleton.hopix

INPUT:
type list = Nil | Cons (int, list)

fun singleton (l) = l ? Cons (_, Nil) => true | _ => false

val main =
  if singleton (Nil) then print_string ("true") else print_string ("false")

OUTPUT: 

Failure("NoSuchFunction: block_create")
EXPECTED: 
false
--------------------------------------------------------
[ KO ]   -->  sum.hopix

INPUT:
fun sum (x, y, z, t, u) =
  if x = 0 then y + z + t + u else 1 + sum (x - 1, y, z, t, u)

val main = print_int (sum (1, 2, 3, 4, 5))

OUTPUT: 

Failure("NoSuchFunction: print_int")
EXPECTED: 
15
--------------------------------------------------------
GOOD: 0 / 47

BAD:  0 / 0
make[1]: Leaving directory '/home/opam/source/flap/tests-flap/hopix/retrolix/good'
--------------------------------------------------------
Global results:
BAD:   0 / 0
GOOD:  89 / 141
--------------------------------------------------------
make: Leaving directory '/home/opam/source/flap/tests-flap'
