make: Entering directory '/home/opam/source/flap/tests-m3'
make -C ..
make[1]: Entering directory '/home/opam/source/flap'
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
make[1]: Leaving directory '/home/opam/source/flap'
make[1]: Entering directory '/home/opam/source/flap/tests-m3/hopix/typechecker/bad'
========================================================
In typechecker/bad
GOOD: 0 / 0
[XFAIL]  andpatterns.hopix

INPUT: 
type t = A | B (int)

val test1 = A ? { A & B (x : bool) => 0 | B (_ : int) => 1 }
OUTPUT: 
Line 3, characters 22-34: Error (typechecking)
  Type error:
Expected:
  int -> t
Given:
  bool -> 'a2

--------------------------------------------------------
[XFAIL]  andpatterns2.hopix

INPUT: 
type t = A (int) | B

val test1 = A (0) ? { A (x : bool) & (y : t ()) => x | B => 1 }

val test2 = A (0) ? { A (_ : int) & (y : t ()) => y | B => A (0) }
OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
[XFAIL]  apply.hopix

INPUT: 
fun apply['a, 'b] (f : 'a -> 'b, x : 'a) : 'b =
  f (x)

fun succ (x : int) : int = x + 1

val one = apply[int, bool] (succ, 0)
OUTPUT: 
Line 6, characters 28-32: Error (typechecking)
  Type error:
Expected:
  int -> bool
Given:
  int -> int

--------------------------------------------------------
[XFAIL]  arith.hopix

INPUT: 
val x : string = 1 + 1
OUTPUT: 
Line 1, characters 17-22: Error (typechecking)
  Type error:
Expected:
  string
Given:
  int

--------------------------------------------------------
[XFAIL]  arith2.hopix

INPUT: 
val x : string = 1 + 1 * 3
OUTPUT: 
Line 1, characters 17-26: Error (typechecking)
  Type error:
Expected:
  string
Given:
  int

--------------------------------------------------------
[XFAIL]  arith3.hopix

INPUT: 
val x : int = 1 + 1 * 3
val y : int = z / 2 - 3
OUTPUT: 
Line 2, characters 14-15: Error (typechecking)
  Unbound identifier z.
--------------------------------------------------------
[XFAIL]  bool.hopix

INPUT: 
val t : bool = true
val f : bool = 0
OUTPUT: 
Line 2, characters 15-16: Error (typechecking)
  Type error:
Expected:
  bool
Given:
  int

--------------------------------------------------------
[XFAIL]  case.hopix

INPUT: 
type t = A | B

val test1 : int = A ? { A => 0 | B => 1 }

fun f (x : t (int)) : int = x ? { A => 0 | B => 1 }

val test2 : int = f (A)
OUTPUT: 
Line 5, characters 11-18: Error (typechecking)
  The type constructor t has arity 0 and not 1.
--------------------------------------------------------
[XFAIL]  external.hopix

INPUT: 
extern p : int * bool -> int

val x : int = p (0, 1)
OUTPUT: 
Line 3, characters 20-21: Error (typechecking)
  Type error:
Expected:
  bool
Given:
  int

--------------------------------------------------------
[XFAIL]  id.hopix

INPUT: 
val id = \(x : 'a) => (x : 'a)
OUTPUT: 
Line 1, characters 15-17: Error (typechecking)
  Unbound type variable 'a.
--------------------------------------------------------
[XFAIL]  idapp.hopix

INPUT: 
val zero = (\['a](x : 'a) => (x : 'a))[bool](0)

OUTPUT: 
Line 1, characters 45-46: Error (typechecking)
  Type error:
Expected:
  bool
Given:
  int

--------------------------------------------------------
[XFAIL]  if.hopix

INPUT: 
val test : int =
  if true then 0 else true
OUTPUT: 
Line 2, characters 15-16: Error (typechecking)
  Type error:
Expected:
  bool
Given:
  int

--------------------------------------------------------
[XFAIL]  if1.hopix

INPUT: 
val test : string =
  if true then "string" else 0
OUTPUT: 
Line 2, characters 15-23: Error (typechecking)
  Type error:
Expected:
  int
Given:
  string

--------------------------------------------------------
[XFAIL]  if2.hopix

INPUT: 
val test : int =
  if true then 0 else if false then 1 else 'a'
OUTPUT: 
Line 2, characters 36-37: Error (typechecking)
  Type error:
Expected:
  char
Given:
  int

--------------------------------------------------------
[XFAIL]  if3.hopix

INPUT: 
val x = 1

val test : int =
  if x = 0 then 0
  else if x = 1 then 1
  else if x > 'a' then 2
  else if x < 0 then 3
  else if x <= 0 then 4
  else if x >= 0 then 5
  else if x = 0 && x > 0 then 6
  else 33
OUTPUT: 
Line 6, characters 14-17: Error (typechecking)
  Type error:
Expected:
  int
Given:
  char

--------------------------------------------------------
[XFAIL]  if4.hopix

INPUT: 
val x = 3
val test : unit =
  if x = 0 then 0

OUTPUT: 
Line 3, characters 16-17: Error (typechecking)
  Type error:
Expected:
  unit
Given:
  int

--------------------------------------------------------
[XFAIL]  int.hopix

INPUT: 
val x : bool = 42
OUTPUT: 
Line 1, characters 15-17: Error (typechecking)
  Type error:
Expected:
  bool
Given:
  int

--------------------------------------------------------
[XFAIL]  litpatterns.hopix

INPUT: 
val x : int = 3 ? { 3 => 0 | (_ : int) => "yo" }
OUTPUT: 
Line 1, characters 42-46: Error (typechecking)
  Type error:
Expected:
  int
Given:
  string

--------------------------------------------------------
[XFAIL]  litpatterns2.hopix

INPUT: 
val x : int = "Darth" ? { "Yoda" => 0 | 0 => 1 | (_ : string) => 2 }
OUTPUT: 
Line 1, characters 40-41: Error (typechecking)
  Type error:
Expected:
  int
Given:
  string

--------------------------------------------------------
[XFAIL]  litpatterns3.hopix

INPUT: 
val x : int = 'a' ? { 'b' => 0 | 'c' => 1 | (_ : int) => 2 }
OUTPUT: 
Line 1, characters 44-53: Error (typechecking)
  Type error:
Expected:
  int
Given:
  char

--------------------------------------------------------
[XFAIL]  local.hopix

INPUT: 
val test : int =
  val x : int = 'a';
  val z : int -> int = \(x : int) => x + 1;
  val u : int = z (x);
  u
OUTPUT: 
Line 2, characters 16-19: Error (typechecking)
  Type error:
Expected:
  int
Given:
  char

--------------------------------------------------------
[XFAIL]  local1.hopix

INPUT: 
val test : int =
  val x : int = (
    val z : int -> int = \(x : int) => x + 1;
    val u : int = z (true);
    u
  );
  x
OUTPUT: 
Line 4, characters 21-25: Error (typechecking)
  Type error:
Expected:
  int
Given:
  bool

--------------------------------------------------------
[XFAIL]  memory.hopix

INPUT: 
val r : cell (int) = ref ("not me!")
OUTPUT: 
Line 1, characters 21-36: Error (typechecking)
  Type error:
Expected:
  cell(int)
Given:
  cell(string)

--------------------------------------------------------
[XFAIL]  memory1.hopix

INPUT: 
val r : cell (int) = ref (0)

val write : unit =
  r := "not me!"
OUTPUT: 
Line 4, characters 7-16: Error (typechecking)
  Type error:
Expected:
  int
Given:
  string

--------------------------------------------------------
[XFAIL]  memory2.hopix

INPUT: 
val r : cell (int) = ref (0)

val write : unit =
  r := 42

val read : string =
  !r
OUTPUT: 
Line 7, characters 2-4: Error (typechecking)
  Type error:
Expected:
  string
Given:
  int

--------------------------------------------------------
[XFAIL]  multipatterns.hopix

INPUT: 
type t = A
type u = S (u) | T (int)

val x : int = S (A) ? {
| S (A | B)  => 0
| (_ : u) => 1
}
OUTPUT: 
Line 4, characters 17-18: Error (typechecking)
  Type error:
Expected:
  u
Given:
  t

--------------------------------------------------------
[XFAIL]  noarg.hopix

INPUT: 
fun f (x : unit) : unit = f (0)

val test : unit = f (nothing)
OUTPUT: 
Line 1, characters 29-30: Error (typechecking)
  Type error:
Expected:
  unit
Given:
  int

--------------------------------------------------------
[XFAIL]  nonlinearpatterns.hopix

INPUT: 
type t = A (int, int)

val test = A (0, 0) ? { A (x: int, x : int) => 0 }
OUTPUT: 
Line 3, characters 24-43: Error (typechecking)
  The identifier x is bound several times in this pattern.
--------------------------------------------------------
[XFAIL]  option.hopix

INPUT: 
type option ('a) =
| None
| Some ('a)

fun unSome (o : option (int), default: int) : bool =
  o ? {
  | (None : option (int)) => default
  | Some (x : int) => x
  }
OUTPUT: 
Line 6, characters 2-72: Error (typechecking)
  Type error:
Expected:
  bool
Given:
  int

--------------------------------------------------------
[XFAIL]  orpatterns.hopix

INPUT: 
type t = A (int) | B (int) | C

val test1 : int = A (0) ? {
| A (x : int) | B (x : int) => x
| D => 0
}


OUTPUT: 
Line 5, characters 2-3: Error (typechecking)
  Unbound data constructor D.
--------------------------------------------------------
[XFAIL]  orpatterns2.hopix

INPUT: 
type u = A (int) | B (int) | C

val test1 : int = A (0, 0) ? {
| A (x : int, (_ : int)) | B (x : int) => x
| C => 0
}


OUTPUT: 
Line 3, characters 18-26: Error (typechecking)
  The data constructor A has arity 1 and not 2.
--------------------------------------------------------
[XFAIL]  orpatterns3.hopix

INPUT: 
type t = A (int) | B (int)

val x = A (3) ? A (x : int) | B (y : int) => x
OUTPUT: 
Line 3, characters 30-41: Error (typechecking)
  All patterns of a disjunctive pattern must bind the same set of identifiers.
--------------------------------------------------------
[XFAIL]  polymorphism.hopix

INPUT: 
fun id ['a] (x : 'a) : 'b = x

val y : int = id [int] (42)
OUTPUT: 
Line 1, characters 23-25: Error (typechecking)
  Unbound type variable 'b.
--------------------------------------------------------
[XFAIL]  polymorphism2.hopix

INPUT: 
fun apply ['a, 'b] (f : 'a -> 'b, x : 'b) : 'a = f (x)

val y : int = apply [int, int](\(x : int) => x, 0)
OUTPUT: 
Line 1, characters 52-53: Error (typechecking)
  Type error:
Expected:
  'a
Given:
  'b

--------------------------------------------------------
[XFAIL]  polymorphism3.hopix

INPUT: 
type t ('a) = K ('a)

fun open ['a] (x : t ()) : 'a =
  x ? K (y : 'a) => y

val y : int = open[int] (K[int] (1))
OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
[XFAIL]  polymorphism4.hopix

INPUT: 
type t ('a) = K ('a)

fun map ['a, 'b] (x : t ('a, 'b), f : 'a -> 'b) : t('b) =
  x ? K (y : 'a) => K ['b] (f (y))

fun id ['a] (x : t ('a)) : t ('a) =
  map['a, 'a] (x, \(y : 'a) => y)

val test = id[int] (K[int] (33))
OUTPUT: 
Line 3, characters 22-32: Error (typechecking)
  The type constructor t has arity 1 and not 2.
--------------------------------------------------------
[XFAIL]  polymorphism5.hopix

INPUT: 
type t ('a) = K ('a -> 'b)

fun compose ['a, 'b, 'c] (x : t ('a, 'b), f : 'b -> 'c) : t('a, 'c) =
  x ? K (g : 'a -> 'b) => K ['a, 'c] (\(x : 'a) => f (g (x)))

val tid : t (int, int)   = K[int, int] (\(x : int) => x)

val tsucc : t (int, int) = compose[int, int, int] (tid, \(x : int) => x + 1)

val tdble : t (int, int) = compose[int, int, int] (tsucc, \(x : int) => x * 2)



OUTPUT: 
Line 1, characters 17-25: Error (typechecking)
  Unbound type variable 'b.
--------------------------------------------------------
[XFAIL]  recfuns.hopix

INPUT: 
fun f (x : int) : int =
  g (x + 1) + 1
OUTPUT: 
Line 2, characters 2-3: Error (typechecking)
  Unbound identifier g.
--------------------------------------------------------
[XFAIL]  recfuns2.hopix

INPUT: 
fun f (x : int) : int =
  f (x + 1) + h (x)
and g (x : int) : int =
  g (f (0))
OUTPUT: 
Line 2, characters 14-15: Error (typechecking)
  Unbound identifier h.
--------------------------------------------------------
[XFAIL]  recfuns3.hopix

INPUT: 
fun f (x : int, s : string) : int =
  f (x + 1, s) + g (x, s)
and g (x : int) : int =
  g (f (0, "yo"))
OUTPUT: 
Line 2, characters 17-18: Error (typechecking)
  This function has arity 1 and not 2.
--------------------------------------------------------
[XFAIL]  restrictpoly.hopix

INPUT: 
fun id['a] (x: 'a) : 'a = x

fun twice (f : int -> int) : int -> int =
    \(x : int) => f (f (x))

val zero = twice (\(x : int) => id[bool] (x)) (0)
OUTPUT: 
Line 6, characters 42-43: Error (typechecking)
  Type error:
Expected:
  bool
Given:
  int

--------------------------------------------------------
[XFAIL]  slam.hopix

INPUT: 
type list ('a) =
| Nil
| Cons ('a, list ('a))

fun nil['a] (x : unit) : list ('a) = Nil['a]

fun cons['a] (x : 'a, xs : list('a)) : list ('a) = Cons['a] (x, xs)

fun map['a, 'b] (f : 'a -> 'b, l : list ('a)) : list ('b) =
  l ? {
  | (Nil : list ('a)) =>
    nil['a] (nothing)
  | Cons (x : 'a, xs : list ('a)) =>
    cons['b] (f (x), map['a, 'b] (f, xs))
 }

fun append['a] (l1 : list ('a), l2 : list ('a)) : list ('a) =
  l1 ? {
  | (Nil : list ('a)) =>
    l2
  | Cons (x : 'a, xs : list ('a)) =>
    cons['a] (x, append['a] (xs, l2))
  }

fun flatten['a] (l : list (list ('a))) : list ('a) =
  l ? {
  | (Nil : list (list ('a))) =>
    nil['a] (nothing)
  | Cons (l : list ('a), ls : list (list ('a))) =>
    append['a] (l, flatten['a] (ls))
  }

fun return['a] (x : 'a) : list ('a)  = cons['a] (x, nil['a] (nothing))
fun bind['a, 'b] (m : list ('a), f : 'a -> list ('b)) : list ('b) =
  flatten['b] (map['a, list ('b)] (f, m))

fun choice['a] (a : 'a, b : 'a) : list ('a) = cons['a] (a, cons['a] (b, nil['a] (nothing)))

fun bits (n : int) : list (list (int)) =
  if n = 0 then return[list (int)] (nil[int] (nothing)) else
    bind[int, list (int)] (choice[int] (0, 1), \(b : int) =>
      bind[list (int), list (int)] (bits (n - 1), \(bs : list (int)) =>
	return[list (int)] (cons[int] (b, bs))
     )
    )

val all_bytes : list (list (int)) = bits (8)

fun iter['a] (f : 'a -> unit, l : list ('a)) : unit =
  l ? {
  | (Nil : list ('a)) =>
    nothing
  | Cons (x : 'a, xs : list ('a)) => (
     f (x);
     iter['a] (f, xs)
    )
  }

fun print_bits (bs : list (int)) : unit =
  print_string ("[");
  fun aux (bs : list (int)) : unit =
    bs ? {
    | (Nil : list (int)) => print_string ("")
    | Cons (b : int, bs : list (int)) => (print_int (b); print_string (";"); aux (bs))
    };
  aux (bs);
  print_string ("]")

val main1 =
  iter[list (int)] (\(b : list (int)) => (print_bits (b); print_string ("\n")),
	all_bytes)

val all_word12 : list (list (int)) = bits (12)

fun fold['a, 'b] (f : 'b * 'a -> 'b, accu : 'b, l : list ('a)) : 'b = l? {
  | (Nil : list ('a)) => accu
  | Cons (x : 'a, xs : list ('a)) => fold['a, 'b] (f, f (accu, x), xs)
}

fun ones (b : list (int)) : int =
  fold[int, int] ((\(a : int, b : int) => a + b), 0, b)

val main2 =
    val count = ref (0);
    iter[list (int)] (\(b : list (int)) => count := !count + ones (b), all_word12);
    print_int (!count)

OUTPUT: 
Line 14, characters 4-41: Error (typechecking)
  Type error:
Expected:
  list('a)
Given:
  list('b)

--------------------------------------------------------
[XFAIL]  slam1.hopix

INPUT: 
type list ('a) =
| Nil
| Cons ('a, list ('a))

fun nil['a] (x : unit) : list ('a) = Nil['a]

fun cons['a] (x : 'a, xs : list('a)) : list ('a) = Cons['a] (x, xs)

fun map['a, 'b] (f : 'a -> 'b, l : list ('a)) : list ('b) =
  l ? {
  | (Nil : list ('a)) =>
    nil['b] (nothing)
  | Cons (x : 'a, xs : list ('a)) =>
    cons['a] (f (x), map['a, 'b] (f, xs))
 }

fun append['a] (l1 : list ('a), l2 : list ('a)) : list ('a) =
  l1 ? {
  | (Nil : list ('a)) =>
    l2
  | Cons (x : 'a, xs : list ('a)) =>
    cons['a] (x, append['a] (xs, l2))
  }

fun flatten['a] (l : list (list ('a))) : list ('a) =
  l ? {
  | (Nil : list (list ('a))) =>
    nil['a] (nothing)
  | Cons (l : list ('a), ls : list (list ('a))) =>
    append['a] (l, flatten['a] (ls))
  }

fun return['a] (x : 'a) : list ('a)  = cons['a] (x, nil['a] (nothing))
fun bind['a, 'b] (m : list ('a), f : 'a -> list ('b)) : list ('b) = 
  flatten['b] (map['a, list ('b)] (f, m))

fun choice['a] (a : 'a, b : 'a) : list ('a) = cons['a] (a, cons['a] (b, nil['a] (nothing)))

fun bits (n : int) : list (list (int)) =
  if n = 0 then return[list (int)] (nil[int] (nothing)) else
    bind[int, list (int)] (choice[int] (0, 1), \(b : int) =>
      bind[list (int), list (int)] (bits (n - 1), \(bs : list (int)) =>
	return[list (int)] (cons[int] (b, bs))
     )
    )

val all_bytes : list (list (int)) = bits (8)

fun iter['a] (f : 'a -> unit, l : list ('a)) : unit =
  l ? {
  | (Nil : list ('a)) =>
    nothing
  | Cons (x : 'a, xs : list ('a)) => (
     f (x);
     iter['a] (f, xs)
    )
  }

fun print_bits (bs : list (int)) : unit =
  print_string ("[");
  fun aux (bs : list (int)) : unit =
    bs ? {
    | (Nil : list (int)) => print_string ("")
    | Cons (b : int, bs : list (int)) => (print_int (b); print_string (";"); aux (bs))
    };
  aux (bs);
  print_string ("]")

val main1 =
  iter[list (int)] (\(b : list (int)) => (print_bits (b); print_string ("\n")),
	all_bytes)

val all_word12 : list (list (int)) = bits (12)

fun fold['a, 'b] (f : 'b * 'a -> 'b, accu : 'b, l : list ('a)) : 'b = l? {
  | (Nil : list ('a)) => accu
  | Cons (x : 'a, xs : list ('a)) => fold['a, 'b] (f, f (accu, x), xs)
}

fun ones (b : list (int)) : int =
  fold[int, int] ((\(a : int, b : int) => a + b), 0, b)

val main2 =
    val count = ref (0);
    iter[list (int)] (\(b : list (int)) => count := !count + ones (b), all_word12);
    print_int (!count)

OUTPUT: 
Line 14, characters 14-19: Error (typechecking)
  Type error:
Expected:
  'a
Given:
  'b

--------------------------------------------------------
[XFAIL]  slam2.hopix

INPUT: 
type list ('a) =
| Nil
| Cons ('a, list ('a))

fun nil['a] (x : unit) : list ('a) = Nil['a]

fun cons['a] (x : 'a, xs : list('a)) : list ('a) = Cons['a] (x, xs)

fun map['a, 'b] (f : 'a -> 'b, l : list ('a)) : list ('b) =
  l ? {
  | (Nil : list ('a)) =>
    nil['b] (nothing)
  | Cons (x : 'a, xs : list ('a)) =>
    cons['b] (map['a, 'b] (f, xs))
 }

fun append['a] (l1 : list ('a), l2 : list ('a)) : list ('a) =
  l1 ? {
  | (Nil : list ('a)) =>
    l2
  | Cons (x : 'a, xs : list ('a)) =>
    cons['a] (x, append['a] (xs, l2))
  }

fun flatten['a] (l : list (list ('a))) : list ('a) =
  l ? {
  | (Nil : list (list ('a))) =>
    nil['a] (nothing)
  | Cons (l : list ('a), ls : list (list ('a))) =>
    append['a] (l, flatten['a] (ls))
  }

fun return['a] (x : 'a) : list ('a)  = cons['a] (x, nil['a] (nothing))
fun bind['a, 'b] (m : list ('a), f : 'a -> list ('b)) : list ('b) = 
  flatten['b] (map['a, list ('b)] (f, m))

fun choice['a] (a : 'a, b : 'a) : list ('a) = cons['a] (a, cons['a] (b, nil['a] (nothing)))

fun bits (n : int) : list (list (int)) =
  if n = 0 then return[list (int)] (nil[int] (nothing)) else
    bind[int, list (int)] (choice[int] (0, 1), \(b : int) =>
      bind[list (int), list (int)] (bits (n - 1), \(bs : list (int)) =>
	return[list (int)] (cons[int] (b, bs))
     )
    )

val all_bytes : list (list (int)) = bits (8)

fun iter['a] (f : 'a -> unit, l : list ('a)) : unit =
  l ? {
  | (Nil : list ('a)) =>
    nothing
  | Cons (x : 'a, xs : list ('a)) => (
     f (x);
     iter['a] (f, xs)
    )
  }

fun print_bits (bs : list (int)) : unit =
  print_string ("[");
  fun aux (bs : list (int)) : unit =
    bs ? {
    | (Nil : list (int)) => print_string ("")
    | Cons (b : int, bs : list (int)) => (print_int (b); print_string (";"); aux (bs))
    };
  aux (bs);
  print_string ("]")

val main1 =
  iter[list (int)] (\(b : list (int)) => (print_bits (b); print_string ("\n")),
	all_bytes)

val all_word12 : list (list (int)) = bits (12)

fun fold['a, 'b] (f : 'b * 'a -> 'b, accu : 'b, l : list ('a)) : 'b = l? {
  | (Nil : list ('a)) => accu
  | Cons (x : 'a, xs : list ('a)) => fold['a, 'b] (f, f (accu, x), xs)
}

fun ones (b : list (int)) : int =
  fold[int, int] ((\(a : int, b : int) => a + b), 0, b)

val main2 =
    val count = ref (0);
    iter[list (int)] (\(b : list (int)) => count := !count + ones (b), all_word12);
    print_int (!count)

OUTPUT: 
Line 14, characters 14-33: Error (typechecking)
  Type error:
Expected:
  'b
Given:
  list('b)

--------------------------------------------------------
[XFAIL]  slam4.hopix

INPUT: 
type list ('a) =
| Nil
| Cons ('a, list ('a))

fun nil['a] (x : unit) : list ('a) = Nil['a]

fun cons['a] (x : 'a, xs : list('a)) : list ('a) = Cons['a] (x, xs)

fun map['a, 'b] (f : 'a -> 'b, l : list ('a)) : list ('b) =
  l ? {
  | (Nil : list ('a)) =>
    nil['b] (nothing)
  | Cons (x : 'a, xs : list ('a)) =>
    cons['b] (f (x), map['a] (f, xs))
 }

fun append['a] (l1 : list ('a), l2 : list ('a)) : list ('a) =
  l1 ? {
  | (Nil : list ('a)) =>
    l2
  | Cons (x : 'a, xs : list ('a)) =>
    cons['a] (x, append['a] (xs, l2))
  }

fun flatten['a] (l : list (list ('a))) : list ('a) =
  l ? {
  | (Nil : list (list ('a))) =>
    nil['a] (nothing)
  | Cons (l : list ('a), ls : list (list ('a))) =>
    append['a] (l, flatten['a] (ls))
  }

fun return['a] (x : 'a) : list ('a)  = cons['a] (x, nil['a] (nothing))
fun bind['a, 'b] (m : list ('a), f : 'a -> list ('b)) : list ('b) = 
  flatten['b] (map['a, list ('b)] (f, m))

fun choice['a] (a : 'a, b : 'a) : list ('a) = cons['a] (a, cons['a] (b, nil['a] (nothing)))

fun bits (n : int) : list (list (int)) =
  if n = 0 then return[list (int)] (nil[int] (nothing)) else
    bind[int, list (int)] (choice[int] (0, 1), \(b : int) =>
      bind[list (int), list (int)] (bits (n - 1), \(bs : list (int)) =>
	return[list (int)] (cons[int] (b, bs))
     )
    )

val all_bytes : list (list (int)) = bits (8)

fun iter['a] (f : 'a -> unit, l : list ('a)) : unit =
  l ? {
  | (Nil : list ('a)) =>
    nothing
  | Cons (x : 'a, xs : list ('a)) => (
     f (x);
     iter['a] (f, xs)
    )
  }

fun print_bits (bs : list (int)) : unit =
  print_string ("[");
  fun aux (bs : list (int)) : unit =
    bs ? {
    | (Nil : list (int)) => print_string ("")
    | Cons (b : int, bs : list (int)) => (print_int (b); print_string (";"); aux (bs))
    };
  aux (bs);
  print_string ("]")

val main1 =
  iter[list (int)] (\(b : list (int)) => (print_bits (b); print_string ("\n")),
	all_bytes)

val all_word12 : list (list (int)) = bits (12)

fun fold['a, 'b] (f : 'b * 'a -> 'b, accu : 'b, l : list ('a)) : 'b = l? {
  | (Nil : list ('a)) => accu
  | Cons (x : 'a, xs : list ('a)) => fold['a, 'b] (f, f (accu, x), xs)
}

fun ones (b : list (int)) : int =
  fold[int, int] ((\(a : int, b : int) => a + b), 0, b)

val main2 =
    val count = ref (0);
    iter[list (int)] (\(b : list (int)) => count := !count + ones (b), all_word12);
    print_int (!count)

OUTPUT: 
Line 14, characters 21-24: Error (typechecking)
  Invalid type instantiation: expected 2 type(s) and not 1.
--------------------------------------------------------
[XFAIL]  slam5.hopix

INPUT: 
type list ('a) =
| Nil
| Cons ('a, list ())

fun nil['a] (x : unit) : list ('a) = Nil['a]

fun cons['a] (x : 'a, xs : list('a)) : list ('a) = Cons['a] (x, xs)

fun map['a, 'b] (f : 'a -> 'b, l : list ('a)) : list ('b) =
  l ? {
  | (Nil : list ('a)) =>
    nil['b] (nothing)
  | Cons (x : 'a, xs : list ('a)) =>
    cons['b] (f (x), map['a, 'b] (f, xs))
 }

fun append['a] (l1 : list ('a), l2 : list ('a)) : list ('a) =
  l1 ? {
  | (Nil : list ('a)) =>
    l2
  | Cons (x : 'a, xs : list ('a)) =>
    cons['a] (x, append['a] (xs, l2))
  }

fun flatten['a] (l : list (list ('a))) : list ('a) =
  l ? {
  | (Nil : list (list ('a))) =>
    nil['a] (nothing)
  | Cons (l : list ('a), ls : list (list ('a))) =>
    append['a] (l, flatten['a] (ls))
  }

fun return['a] (x : 'a) : list ('a)  = cons['a] (x, nil['a] (nothing))
fun bind['a, 'b] (m : list ('a), f : 'a -> list ('b)) : list ('b) = 
  flatten['b] (map['a, list ('b)] (f, m))

fun choice['a] (a : 'a, b : 'a) : list ('a) = cons['a] (a, cons['a] (b, nil['a] (nothing)))

fun bits (n : int) : list (list (int)) =
  if n = 0 then return[list (int)] (nil[int] (nothing)) else
    bind[int, list (int)] (choice[int] (0, 1), \(b : int) =>
      bind[list (int), list (int)] (bits (n - 1), \(bs : list (int)) =>
	return[list (int)] (cons[int] (b, bs))
     )
    )

val all_bytes : list (list (int)) = bits (8)

fun iter['a] (f : 'a -> unit, l : list ('a)) : unit =
  l ? {
  | (Nil : list ('a)) =>
    nothing
  | Cons (x : 'a, xs : list ('a)) => (
     f (x);
     iter['a] (f, xs)
    )
  }

fun print_bits (bs : list (int)) : unit =
  print_string ("[");
  fun aux (bs : list (int)) : unit =
    bs ? {
    | (Nil : list (int)) => print_string ("")
    | Cons (b : int, bs : list (int)) => (print_int (b); print_string (";"); aux (bs))
    };
  aux (bs);
  print_string ("]")

val main1 =
  iter[list (int)] (\(b : list (int)) => (print_bits (b); print_string ("\n")),
	all_bytes)

val all_word12 : list (list (int)) = bits (12)

fun fold['a, 'b] (f : 'b * 'a -> 'b, accu : 'b, l : list ('a)) : 'b = l? {
  | (Nil : list ('a)) => accu
  | Cons (x : 'a, xs : list ('a)) => fold['a, 'b] (f, f (accu, x), xs)
}

fun ones (b : list (int)) : int =
  fold[int, int] ((\(a : int, b : int) => a + b), 0, b)

val main2 =
    val count = ref (0);
    iter[list (int)] (\(b : list (int)) => count := !count + ones (b), all_word12);
    print_int (!count)

OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
[XFAIL]  slam6.hopix

INPUT: 
type list ('a) =
| Nil
| Cons ('a, list ('a, 'b))

fun nil['a] (x : unit) : list ('a) = Nil['a]

fun cons['a] (x : 'a, xs : list('a)) : list ('a) = Cons['a] (x, xs)

fun map['a, 'b] (f : 'a -> 'b, l : list ('a)) : list ('b) =
  l ? {
  | (Nil : list ('a)) =>
    nil['b] (nothing)
  | Cons (x : 'a, xs : list ('a)) =>
    cons['b] (f (x), map['a, 'b] (f, xs))
 }

fun append['a] (l1 : list ('a), l2 : list ('a)) : list ('a) =
  l1 ? {
  | (Nil : list ('a)) =>
    l2
  | Cons (x : 'a, xs : list ('a)) =>
    cons['a] (x, append['a] (xs, l2))
  }

fun flatten['a] (l : list (list ('a))) : list ('a) =
  l ? {
  | (Nil : list (list ('a))) =>
    nil['a] (nothing)
  | Cons (l : list ('a), ls : list (list ('a))) =>
    append['a] (l, flatten['a] (ls))
  }

fun return['a] (x : 'a) : list ('a)  = cons['a] (x, nil['a] (nothing))
fun bind['a, 'b] (m : list ('a), f : 'a -> list ('b)) : list ('b) = 
  flatten['b] (map['a, list ('b)] (f, m))

fun choice['a] (a : 'a, b : 'a) : list ('a) = cons['a] (a, cons['a] (b, nil['a] (nothing)))

fun bits (n : int) : list (list (int)) =
  if n = 0 then return[list (int)] (nil[int] (nothing)) else
    bind[int, list (int)] (choice[int] (0, 1), \(b : int) =>
      bind[list (int), list (int)] (bits (n - 1), \(bs : list (int)) =>
	return[list (int)] (cons[int] (b, bs))
     )
    )

val all_bytes : list (list (int)) = bits (8)

fun iter['a] (f : 'a -> unit, l : list ('a)) : unit =
  l ? {
  | (Nil : list ('a)) =>
    nothing
  | Cons (x : 'a, xs : list ('a)) => (
     f (x);
     iter['a] (f, xs)
    )
  }

fun print_bits (bs : list (int)) : unit =
  print_string ("[");
  fun aux (bs : list (int)) : unit =
    bs ? {
    | (Nil : list (int)) => print_string ("")
    | Cons (b : int, bs : list (int)) => (print_int (b); print_string (";"); aux (bs))
    };
  aux (bs);
  print_string ("]")

val main1 =
  iter[list (int)] (\(b : list (int)) => (print_bits (b); print_string ("\n")),
	all_bytes)

val all_word12 : list (list (int)) = bits (12)

fun fold['a, 'b] (f : 'b * 'a -> 'b, accu : 'b, l : list ('a)) : 'b = l? {
  | (Nil : list ('a)) => accu
  | Cons (x : 'a, xs : list ('a)) => fold['a, 'b] (f, f (accu, x), xs)
}

fun ones (b : list (int)) : int =
  fold[int, int] ((\(a : int, b : int) => a + b), 0, b)

val main2 =
    val count = ref (0);
    iter[list (int)] (\(b : list (int)) => count := !count + ones (b), all_word12);
    print_int (!count)

OUTPUT: 
Line 3, characters 12-25: Error (typechecking)
  The type constructor list has arity 1 and not 2.
--------------------------------------------------------
[XFAIL]  string.hopix

INPUT: 
val s : int = "foobar"
OUTPUT: 
Line 1, characters 14-22: Error (typechecking)
  Type error:
Expected:
  int
Given:
  string

--------------------------------------------------------
[XFAIL]  val.hopix

INPUT: 
val x : bool = 1

OUTPUT: 
Line 1, characters 15-16: Error (typechecking)
  Type error:
Expected:
  bool
Given:
  int

--------------------------------------------------------
[XFAIL]  while.hopix

INPUT: 
fun f (x : unit) : unit =
 while (0) { f (nothing) }
OUTPUT: 
Line 2, characters 7-10: Error (typechecking)
  Type error:
Expected:
  bool
Given:
  int

--------------------------------------------------------
[XFAIL]  while2.hopix

INPUT: 
fun f (x : unit) : int =
 while (true) { f (nothing) }
OUTPUT: 
Line 2, characters 16-27: Error (typechecking)
  Type error:
Expected:
  unit
Given:
  int

--------------------------------------------------------
[XFAIL]  while3.hopix

INPUT: 
fun f (x : unit) : unit =
 while (true) { 1 }
OUTPUT: 
Line 2, characters 16-17: Error (typechecking)
  Type error:
Expected:
  unit
Given:
  int

--------------------------------------------------------
./andpatterns.hopix ./andpatterns2.hopix ./apply.hopix ./arith.hopix ./arith2.hopix ./arith3.hopix ./bool.hopix ./case.hopix ./external.hopix ./id.hopix ./idapp.hopix ./if.hopix ./if1.hopix ./if2.hopix ./if3.hopix ./if4.hopix ./int.hopix ./litpatterns.hopix ./litpatterns2.hopix ./litpatterns3.hopix ./local.hopix ./local1.hopix ./memory.hopix ./memory1.hopix ./memory2.hopix ./multipatterns.hopix ./noarg.hopix ./nonlinearpatterns.hopix ./option.hopix ./orpatterns.hopix ./orpatterns2.hopix ./orpatterns3.hopix ./polymorphism.hopix ./polymorphism2.hopix ./polymorphism3.hopix ./polymorphism4.hopix ./polymorphism5.hopix ./recfuns.hopix ./recfuns2.hopix ./recfuns3.hopix ./restrictpoly.hopix ./slam.hopix ./slam1.hopix ./slam2.hopix ./slam4.hopix ./slam5.hopix ./slam6.hopix ./string.hopix ./val.hopix ./while.hopix ./while2.hopix ./while3.hopix
BAD:  52 / 52
make[1]: Leaving directory '/home/opam/source/flap/tests-m3/hopix/typechecker/bad'
make[1]: Entering directory '/home/opam/source/flap/tests-m3/hopix/typechecker/good'
========================================================
In typechecker/good
[ OK ]   andpatterns.hopix

INPUT:
type t = A | B

val test1 = A ? { A & A => 0 | B => 1 }
OUTPUT: 
test1 : int
EXPECTED: 
test1 : int
--------------------------------------------------------
[ KO ]   -->  andpatterns2.hopix

INPUT:
type t = A (int) | B

val test1 = A (0) ? { A (x : int) & (y : t ()) => x | B => 1 }

val test2 = A (0) ? { A (_ : int) & (y : t ()) => y | B => A (0) }
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
test1 : int
test2 : t
--------------------------------------------------------
[ OK ]   apply.hopix

INPUT:
fun apply['a, 'b] (f : 'a -> 'b, x : 'a) : 'b =
  f (x)

fun succ (x : int) : int = x + 1

val one = apply[int, int] (succ, 0)
OUTPUT: 
apply : ('a -> 'b) * 'a -> 'b
succ : int -> int
one : int
EXPECTED: 
apply : ('a -> 'b) * 'a -> 'b
succ : int -> int
one : int
--------------------------------------------------------
[ OK ]   arith.hopix

INPUT:
val x = 1 + 1
OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
[ OK ]   arith2.hopix

INPUT:
val x = 1 + 1 * 3
OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
[ OK ]   arith3.hopix

INPUT:
val x = 1 + 1 * 3
val y = x / 2 - 3
OUTPUT: 
x : int
y : int
EXPECTED: 
x : int
y : int
--------------------------------------------------------
[ OK ]   bool.hopix

INPUT:
val t = true
val f = false
OUTPUT: 
t : bool
f : bool
EXPECTED: 
t : bool
f : bool
--------------------------------------------------------
[ OK ]   case.hopix

INPUT:
type t = A | B

val test1 : int = A ? { A => 0 | B => 1 }

fun f (x : t) : int = x ? { A => 0 | B => 1 }

val test2 : int = f (A)
OUTPUT: 
test1 : int
f : t -> int
test2 : int
EXPECTED: 
test1 : int
f : t -> int
test2 : int
--------------------------------------------------------
[ OK ]   external.hopix

INPUT:
extern p : int * int -> int

val x : int = p (0, 1)
OUTPUT: 
p : int * int -> int
x : int
EXPECTED: 
p : int * int -> int
x : int
--------------------------------------------------------
[ OK ]   id.hopix

INPUT:
val id = \['a](x : 'a) => (x : 'a)
OUTPUT: 
id : 'a -> 'a
EXPECTED: 
id : 'a -> 'a
--------------------------------------------------------
[ OK ]   idapp.hopix

INPUT:
val zero = (\['a](x : 'a) => (x : 'a))[int](0)

OUTPUT: 
zero : int
EXPECTED: 
zero : int
--------------------------------------------------------
[ OK ]   if.hopix

INPUT:
val test : int =
  if true then 0 else 1
OUTPUT: 
test : int
EXPECTED: 
test : int
--------------------------------------------------------
[ OK ]   if1.hopix

INPUT:
val test : string =
  if true then "string" else "gnirst"
OUTPUT: 
test : string
EXPECTED: 
test : string
--------------------------------------------------------
[ OK ]   if2.hopix

INPUT:
val test : int =
  if true then 0 else if false then 1 else 2
OUTPUT: 
test : int
EXPECTED: 
test : int
--------------------------------------------------------
[ OK ]   if3.hopix

INPUT:
val x = 1

val test : int =
  if x = 0 then 0
  else if x = 1 then 1
  else if x > 0 then 2
  else if x < 0 then 3
  else if x <= 0 then 4
  else if x >= 0 then 5
  else if x = 0 && x > 0 then 6
  else 33
OUTPUT: 
x : int
test : int
EXPECTED: 
x : int
test : int
--------------------------------------------------------
[ OK ]   if4.hopix

INPUT:
val x = 3
val test : unit =
  if x = 0 then nothing

OUTPUT: 
x : int
test : unit
EXPECTED: 
x : int
test : unit
--------------------------------------------------------
[ OK ]   int.hopix

INPUT:
val x = 42
OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
[ OK ]   litpatterns.hopix

INPUT:
val x : int = 3 ? { 3 => 0 | (_ : int) => 1 }
OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
[ OK ]   litpatterns2.hopix

INPUT:
val x : int = "Darth" ? { "Yoda" => 0 | "Luke" => 1 | (_ : string) => 2 }
OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
[ OK ]   litpatterns3.hopix

INPUT:
val x : int = 'a' ? { 'b' => 0 | 'c' => 1 | (_ : char) => 2 }
OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
[ OK ]   local.hopix

INPUT:
val test : int =
  val x : int = 3;
  val z : int -> int = \(x : int) => x + 1;
  val u : int = z (x);
  u
OUTPUT: 
test : int
EXPECTED: 
test : int
--------------------------------------------------------
[ OK ]   local1.hopix

INPUT:
val test : int =
  val x : int = (
    val z : int -> int = \(x : int) => x + 1;
    val u : int = z (3);
    u
  );
  x
OUTPUT: 
test : int
EXPECTED: 
test : int
--------------------------------------------------------
[ OK ]   memory.hopix

INPUT:
val r : cell (int) = ref (0)
OUTPUT: 
r : cell(int)
EXPECTED: 
r : cell(int)
--------------------------------------------------------
[ OK ]   memory1.hopix

INPUT:
val r : cell (int) = ref (0)

val write : unit =
  r := 42
OUTPUT: 
r : cell(int)
write : unit
EXPECTED: 
r : cell(int)
write : unit
--------------------------------------------------------
[ OK ]   memory2.hopix

INPUT:
val r : cell (int) = ref (0)

val write : unit =
  r := 42

val read : int =
  !r
OUTPUT: 
r : cell(int)
write : unit
read : int
EXPECTED: 
r : cell(int)
write : unit
read : int
--------------------------------------------------------
[ OK ]   multipatterns.hopix

INPUT:
type t = A | B
type u = S (t) | T (int)

val x : int = S (A) ? {
| S (A | B)  => 0
| (_ : u) => 1
}
OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
[ OK ]   noarg.hopix

INPUT:
fun f (x : unit) : unit = f (nothing)

val test : unit = f (nothing)
OUTPUT: 
f : unit -> unit
test : unit
EXPECTED: 
f : unit -> unit
test : unit
--------------------------------------------------------
[ OK ]   option.hopix

INPUT:
type option ('a) =
| None
| Some ('a)

val none = None [int]

fun some (x : int) : option (int) = Some[int] (x)

fun unSome (o : option (int), default: int) : int =
  o ? {
  | (None : option (int)) => default
  | Some (x : int) => x
  }
OUTPUT: 
none : option(int)
some : int -> option(int)
unSome : option(int) * int -> int
EXPECTED: 
none : option(int)
some : int -> option(int)
unSome : option(int) * int -> int
--------------------------------------------------------
[ OK ]   orpatterns.hopix

INPUT:
type t = A (int) | B (int) | C

val test1 : int = A (0) ? {
| A (x : int) | B (x : int) => x
| C => 0
}


OUTPUT: 
test1 : int
EXPECTED: 
test1 : int
--------------------------------------------------------
[ OK ]   orpatterns2.hopix

INPUT:
type u = A (int, int) | B (int) | C

val test1 : int = A (0, 0) ? {
| A (x : int, (_ : int)) | B (x : int) => x
| C => 0
}


OUTPUT: 
test1 : int
EXPECTED: 
test1 : int
--------------------------------------------------------
[ OK ]   polymorphism.hopix

INPUT:
fun id ['a] (x : 'a) : 'a = x

val y : int = id [int] (42)
OUTPUT: 
id : 'a -> 'a
y : int
EXPECTED: 
id : 'a -> 'a
y : int
--------------------------------------------------------
[ OK ]   polymorphism2.hopix

INPUT:
fun apply ['a, 'b] (f : 'a -> 'b, x : 'a) : 'b = f (x)

val y : int = apply [int, int](\(x : int) => x, 0)
OUTPUT: 
apply : ('a -> 'b) * 'a -> 'b
y : int
EXPECTED: 
apply : ('a -> 'b) * 'a -> 'b
y : int
--------------------------------------------------------
[ OK ]   polymorphism3.hopix

INPUT:
type t ('a) = K ('a)

fun open ['a] (x : t ('a)) : 'a =
  x ? K (y : 'a) => y

val y : int = open[int] (K[int] (1))
OUTPUT: 
open : t('a) -> 'a
y : int
EXPECTED: 
open : t('a) -> 'a
y : int
--------------------------------------------------------
[ OK ]   polymorphism4.hopix

INPUT:
type t ('a) = K ('a)

fun map ['a, 'b] (x : t ('a), f : 'a -> 'b) : t('b) =
  x ? K (y : 'a) => K ['b] (f (y))

fun id ['a] (x : t ('a)) : t ('a) =
  map['a, 'a] (x, \(y : 'a) => y)

val test = id[int] (K[int] (33))
OUTPUT: 
map : t('a) * ('a -> 'b) -> t('b)
id : t('a) -> t('a)
test : t(int)
EXPECTED: 
map : t('a) * ('a -> 'b) -> t('b)
id : t('a) -> t('a)
test : t(int)
--------------------------------------------------------
[ OK ]   polymorphism5.hopix

INPUT:
type t ('a, 'b) = K ('a -> 'b)

fun compose ['a, 'b, 'c] (x : t ('a, 'b), f : 'b -> 'c) : t('a, 'c) =
  x ? K (g : 'a -> 'b) => K ['a, 'c] (\(x : 'a) => f (g (x)))

val tid : t (int, int)   = K[int, int] (\(x : int) => x)

val tsucc : t (int, int) = compose[int, int, int] (tid, \(x : int) => x + 1)

val tdble : t (int, int) = compose[int, int, int] (tsucc, \(x : int) => x * 2)



OUTPUT: 
compose : t('a, 'b) * ('b -> 'c) -> t('a, 'c)
tid : t(int, int)
tsucc : t(int, int)
tdble : t(int, int)
EXPECTED: 
compose : t('a, 'b) * ('b -> 'c) -> t('a, 'c)
tid : t(int, int)
tsucc : t(int, int)
tdble : t(int, int)
--------------------------------------------------------
[ OK ]   recfuns.hopix

INPUT:
fun f (x : int) : int =
  f (x + 1) + 1
OUTPUT: 
f : int -> int
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ OK ]   recfuns2.hopix

INPUT:
fun f (x : int) : int =
  f (x + 1) + g (x)
and g (x : int) : int =
  g (f (0))
OUTPUT: 
f : int -> int
g : int -> int
EXPECTED: 
f : int -> int
g : int -> int
--------------------------------------------------------
[ OK ]   recfuns3.hopix

INPUT:
fun f (x : int, s : string) : int =
  f (x + 1, s) + g (x)
and g (x : int) : int =
  g (f (0, "yo"))
OUTPUT: 
f : int * string -> int
g : int -> int
EXPECTED: 
f : int * string -> int
g : int -> int
--------------------------------------------------------
[ OK ]   restrictpoly.hopix

INPUT:
fun id['a] (x: 'a) : 'a = x

fun twice (f : int -> int) : int -> int =
    \(x : int) => f (f (x))

val zero = twice (\(x : int) => id[int] (x)) (0)
OUTPUT: 
id : 'a -> 'a
twice : (int -> int) -> (int -> int)
zero : int
EXPECTED: 
id : 'a -> 'a
twice : (int -> int) -> (int -> int)
zero : int
--------------------------------------------------------
[ KO ]   -->  slam.hopix

INPUT:
type list ('a) =
| Nil
| Cons ('a, list ('a))

fun nil['a] (x : unit) : list ('a) = Nil['a]

fun cons['a] (x : 'a, xs : list('a)) : list ('a) = Cons['a] (x, xs)

fun map['a, 'b] (f : 'a -> 'b, l : list ('a)) : list ('b) =
  l ? {
  | (Nil : list ('a)) =>
    nil['b] (nothing)
  | Cons (x : 'a, xs : list ('a)) =>
    cons['b] (f (x), map['a, 'b] (f, xs))
 }

fun append['a] (l1 : list ('a), l2 : list ('a)) : list ('a) =
  l1 ? {
  | (Nil : list ('a)) =>
    l2
  | Cons (x : 'a, xs : list ('a)) =>
    cons['a] (x, append['a] (xs, l2))
  }

fun flatten['a] (l : list (list ('a))) : list ('a) =
  l ? {
  | (Nil : list (list ('a))) =>
    nil['a] (nothing)
  | Cons (l : list ('a), ls : list (list ('a))) =>
    append['a] (l, flatten['a] (ls))
  }

fun return['a] (x : 'a) : list ('a)  = cons['a] (x, nil['a] (nothing))
fun bind['a, 'b] (m : list ('a), f : 'a -> list ('b)) : list ('b) = 
  flatten['b] (map['a, list ('b)] (f, m))

fun choice['a] (a : 'a, b : 'a) : list ('a) = cons['a] (a, cons['a] (b, nil['a] (nothing)))

fun bits (n : int) : list (list (int)) =
  if n = 0 then return[list (int)] (nil[int] (nothing)) else
    bind[int, list (int)] (choice[int] (0, 1), \(b : int) =>
      bind[list (int), list (int)] (bits (n - 1), \(bs : list (int)) =>
	return[list (int)] (cons[int] (b, bs))
     )
    )

val all_bytes : list (list (int)) = bits (8)

fun iter['a] (f : 'a -> unit, l : list ('a)) : unit =
  l ? {
  | (Nil : list ('a)) =>
    nothing
  | Cons (x : 'a, xs : list ('a)) => (
     f (x);
     iter['a] (f, xs)
    )
  }

fun print_bits (bs : list (int)) : unit =
  print_string ("[");
  fun aux (bs : list (int)) : unit =
    bs ? {
    | (Nil : list (int)) => print_string ("")
    | Cons (b : int, bs : list (int)) => (print_int (b); print_string (";"); aux (bs))
    };
  aux (bs);
  print_string ("]")

val main1 =
  iter[list (int)] (\(b : list (int)) => (print_bits (b); print_string ("\n")),
	all_bytes)

val all_word12 : list (list (int)) = bits (12)

fun fold['a, 'b] (f : 'b * 'a -> 'b, accu : 'b, l : list ('a)) : 'b = l? {
  | (Nil : list ('a)) => accu
  | Cons (x : 'a, xs : list ('a)) => fold['a, 'b] (f, f (accu, x), xs)
}

fun ones (b : list (int)) : int =
  fold[int, int] ((\(a : int, b : int) => a + b), 0, b)

val main2 =
    val count = ref (0);
    iter[list (int)] (\(b : list (int)) => count := !count + ones (b), all_word12);
    print_int (!count)

OUTPUT: 
nil : unit -> list('a)
cons : 'a * list('a) -> list('a)
map : ('a -> 'b) * list('a) -> list('b)
append : list('a) * list('a) -> list('a)
flatten : list(list('a)) -> list('a)
return : 'a -> list('a)
bind : list('a) * ('a -> list('b)) -> list('b)
choice : 'a * 'a -> list('a)
bits : int -> list(list(int))
all_bytes : list(list(int))
iter : ('a -> unit) * list('a) -> unit
print_bits : list(int) -> unit
main1 : unit
all_word12 : list(list(int))
fold : ('b * 'a -> 'b) * 'b * list('a) -> 'b
ones : list(int) -> int
main2 : unit
EXPECTED: 
nil :  -> list('a)
cons : 'a * list('a) -> list('a)
map : ('a -> 'b) * list('a) -> list('b)
append : list('a) * list('a) -> list('a)
flatten : list(list('a)) -> list('a)
return : 'a -> list('a)
bind : list('a) * ('a -> list('b)) -> list('b)
choice : 'a * 'a -> list('a)
bits : int -> list(list(int))
all_bytes : list(list(int))
iter : ('a -> unit) * list('a) -> unit
print_bits : list(int) -> unit
main1 : unit
all_word12 : list(list(int))
fold : ('b * 'a -> 'b) * 'b * list('a) -> 'b
ones : list(int) -> int
main2 : unit
--------------------------------------------------------
[ OK ]   string.hopix

INPUT:
val s = "foobar"
OUTPUT: 
s : string
EXPECTED: 
s : string
--------------------------------------------------------
[ OK ]   while.hopix

INPUT:
fun f (x : unit) : unit =
 while (true) { f (nothing) }
OUTPUT: 
f : unit -> unit
EXPECTED: 
f : unit -> unit
--------------------------------------------------------
GOOD: 40 / 42

BAD:  0 / 0
make[1]: Leaving directory '/home/opam/source/flap/tests-m3/hopix/typechecker/good'
--------------------------------------------------------
Global results:
BAD:   52 / 52
GOOD:  40 / 42
--------------------------------------------------------
make: Leaving directory '/home/opam/source/flap/tests-m3'
