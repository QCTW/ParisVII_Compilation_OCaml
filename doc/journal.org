#+STARTUP: hidestars
#+TODO: TODO(t!) STARTED(s@/!) WAITING(w@/!) SOMEDAY(S@/!) | DONE(d!) CANCELED(c@!)
#+PRIORITIES: A C B

			   *Cours de Compilation*

(Il est préférable d'ouvrir ce fichier texte sous Emacs.)
(Appuyez sur [TAB] pour dérouler les items suivis de "...")

* Cours 1 <2016-09-12>
** Introduction du cours
*** Qu'est-ce qu'un compilateur?
    - définition informelle
    - syntaxe et sémantique d'un langage de programmation
    - définition formelle
*** Pourquoi un cours de compilation en M1?
    - devenir de meilleurs programmeurs
    - apprendre des techniques de programmation utiles au développement
    - un sujet transversal de l'informatique
** Préliminaire: un sondage
   - Qui a déjà programmé en OCaml?
   - Qui a déjà écrit un analyseur syntaxique?
   - Qui a suivi le cours de machine virtuelle?
** Un mini-compilateur pour le langage Marthe
   - voir le fichier marthe.ml
** Le projet de compilation
   - description du projet
   - architecture du projet
   - travail demandé
   - présentation de l'arbre des sources
** Fonctionnement du cours
   - un cours dans Emacs et au tableau
   - un cours orienté "projet"
   - deux semestres pour un premier "gros" projet
   - les jalons et leurs validations
   - des soutenances
   - modalités d'évaluation:
     70% projet + 30% examen sur papier (portant sur le projet)
     Sur la note de projet, 3 points réservés:
     - 1 point si vous avez posé (ou répondu à) au moins 5 questions
       (productions pertinentes, bien formulées) sur le forum.
     - 1 point si vous avez contribué à la réussite globale du projet
       en faisant au moins 5 "pull requests" sur le projet GIT public.
     - 1 point si la moyenne de la promo (moins les "fantômes") est supérieur à 13.
*** DONE Forker le GIT via le gitlab:
    - State "DONE"       from "TODO"       [2016-10-23 Sun 13:14]
    http://moule.informatique.univ-paris-diderot.fr:8080
    DEADLINE:<2016-09-19>
*** DONE Remplir le fichier AUTEURS (2 étudiants par groupes)
    DEADLINE:<2016-09-19>
    - State "DONE"       from "TODO"       [2016-10-23 Sun 13:14]
*** DONE Rajouter les enseignants (via gitlab)
    DEADLINE:<2016-09-19>
    - State "DONE"       from "TODO"       [2016-10-23 Sun 13:15]
    Pierre Letouzey
    Michele Pagani
    Yann Regis-Gianas
*** DONE Faire une pull-request pour mettre à jour le fichier /.mrconfig
    DEADLINE:<2016-09-19>
    - State "DONE"       from "TODO"       [2016-10-23 Sun 13:15]
*** TODO S'inscrire sur http://faq.compilation.hackojo.org
    DEADLINE:<2016-09-19>
*** DONE S'inscrire sur https://groups.google.com/forum/#!forum/compilix
    DEADLINE: <2016-09-19>
    - State "DONE"       from "TODO"       [2016-10-23 Sun 13:16]
*** TODO Travailler régulièrement sur le GIT.
*** TODO Poser des questions sur le site FAQ
* Cours 2 <2016-09-19>
** Retour sur le fonctionnement du cours
   - Forker le GIT.
   - Lire les TODOs dans doc/journal.org
   - 2 cours puis 1 TP
   - Prendre des notes
** L'arbre de sources du compilateur Flap
   - Makefile
   - Arborescence
   - Modules généraux: Languages, Compilers, Flap
   - MiniHopix
   - Méthode de développement dirigée par les tests et incrémentale.
** Les générateurs de code
   - Qu'est-ce que c'est?
   - Pourquoi les utiliser?
** Analyse lexicale
   - Définition
   - Lexèmes et valeurs sémantiques
   - ocamllex
** DONE Lire la documentation de OCamllex
   - State "DONE"       from "TODO"       [2016-11-01 Tue 15:45]
** DONE Lire la documentation de Menhir
   - State "DONE"       from "TODO"       [2016-11-01 Tue 15:45]
** DONE TD1
   - State "DONE"       from "TODO"       [2016-11-01 Tue 15:46]
* Cours 3 <2016-10-03>
** Analyse syntaxique: les définitions
   - Langages
   - Grammaire algébrique
   - Hiérarchie de Chomsky
   - Dérivation d'un mot par une grammaire
   - Multiples dérivations, dérivations équivalentes pour l'analyse
   - Arbre de dérivation d'un mot
   - Ambiguïté
   - Formalisation du problème de l'analyse syntaxique
   - Arbre de syntaxe concrète et arbre de syntaxe abstraite
** Classification des algorithmes d'analyses syntaxiques
   - Algorithmes ascendants
   - Algorithmes descendants
** Menhir, point de vue utilisateur
** Références bibliographiques
   - Appel, "Modern Compiler Implementation" (à la bibliothèque)
   - Grune, "Parsing techniques" (PDF en ligne)
* Cours 4 <2016-10-17>
** Unger
** LL(1)
* Cours 5 <2016-11-07>
** Point projet
** Earley
** LR(0)
** LR(1)
** LALR(1)
* Cours 6 <2016-11-14>
** Point projet
** Syntaxe!
*** BNF d'arbres
    e ::= n | e + e | e * e

    type e = Int of int | Plus of e * e | Mul of e * e
*** Sémantique à petits pas

    ——————————
     1 + 2 → 3
    ———————————————————
    (1 + 2) + 3 → 3 + 3

    —————————
    3 + 3 → 6

*** Différence entre "let x = 1 in ..." et "int x = 1; ..."

    int x = 1;
    y = x + 1;
    ...

    let x = f y in
    x + x

*** Occurrences libres et liées

    let y = *x* in
    let x = 0 in
      /x/ + y

    (en gras : une occurrence libre de x.)
    (en italique : une occurrence liée de x.)

    On peut renommer une occurrence liée :

    let y = *u* in
    let z = 0 in
      /z/ + y


    let x = *x* in /x/

*** Explicitation des fermetures

    y ∈ FV (fun x -> x + y)

    (fun x -> x + y)[ y = 10 ]

* Cours 7 <2016-12-05>
** Rappel des épisodes précédents
   - Notion de syntaxe
   - Notion de liaison de noms
   - Les pointeurs de fonction en C ne sont pas des représentations
     sérieuses des fonctions
   - La notion de fermeture

** Différents évaluateurs pour un langage arithmétique avec "let"
   - Sémantique à petits pas
   - Sémantique à grands pas avec environnements d'évaluation
** Jalon 2 du projet
   - Présentation de la spécification de l'année dernière
   - Règles du "while"
* Cours 8 <2016-12-12>
** Analyse statique
   - Bonne liaison des noms
** Compilation vers une machine
* Cours 9 <2016-12-14> de 9h30 à 11h30 en salle 1008
** Jalon 2
** Examen
** Les fonctions de seconde classe
** Les fonctions de première classe
* Cours 10 <2017-01-17>
** Exceptionnellement, séance de 1h15
** Pas de TD cette semaine
** Où est parti le forum?
** Retour sur le jalon 2
** Présentation de la chaîne de compilation
*** Hopix    -> Hobix
*** Hobix    -> Fopix
*** Fopix    -> Retrolix
*** Retrolix -> Retrolix
*** Retrolix -> MIPS
** TODO Lire la spécification de MIPS
* Cours 11 <2017-01-24>
** TODO MIPS
** TODO Le typage
* Cours 12 <2017-01-31>
** TODO Typage
* Cours 13 <2017-02-07>
** Retour sur le typage
** Inférence de type
*** Problème
    Un programme pas ou peu annoté comme par exemple:

          let f = fun x -> x + 1

*** Solutions
**** Algorithme W
        Soit α le type de x.

	En supposant (x : α), essayons de calculer le
	type de "( + ) x 1". C'est une application, je
	calcule le type de la fonction. `+ a le type
	"int -> (int -> int)". Je dois dois vérifier
	que "x" a le type de l'entrée de cette fonction.

	On doit alors *unifier* le type connu pour "x" et
	le type attendu pour "x". Cela veut que l'on unifie
	"α" et "int".

	On doit aussi vérifier que 1 a le type int.

	Puis on peut déduire que le type de l'application
	est le type de retour de +, i.e. int.

	Donc le type de l'expression "fun x -> x + 1" est
	donc "int -> int".

***** Unification du premier ordre

******* Exemple 1

	P₀ := α₁ -> α₁ =? (α₂ -> int) -> (int -> α₃)

	Au départ la file des problèmes contient seulement
	P₀. On observe le premier problème de la file, c'est P.
	Comme les deux termes à unifier ne sont pas des variables,
	on doit les décomposer : cela insère deux nouveaux problèmes:

	P₁ := α₁ =? (α₂ -> int)
	P₂ := α₁ =? (int -> α₃)

	Par P₁, j'apprends que φ(α₁) = α₂ -> int

	Par P₂, j'apprends que φ(α₁) = int -> α₃

	Comme j'avais déjà une information sur α₁ dans
	φ, je produis un nouveau problème pour vérifier
	que φ reste cohérent:

	P₃ := α₂ -> int =? int -> α₃

	J'applique la règle de décomposition:

	P₄ := α₂ =? int
	P₅ := int =? α₃

	Par P₄, j'apprends que φ(α₂) = int
	Par P₅, j'apprends que φ(α₃) = int

	donc ma solution du problème d'unification initial est:

	φ(α₁) = int -> int
	φ(α₂) = int
	φ(α₃) = int

******* Exemple 2

	P₀ := α₁ -> α₁ =? (α₂ -> α₃) -> (int -> α₃)

	Ici, α₃ n'est pas déterminé.

      L'algorithme W s'appuie sur l'unification du premier ordre.

      t =^? u  –> ⊥ | substitution φ

      On travaille sur une file de problèmes à résoudre,
      chaque problème est un problème d'unification et
      on construit une substitution φ au fur et à mesure
      de la résolution de ces problèmes. On doit
      vérifier que φ n'a pas de cycle.

      • Règle des variables:
      x =? u

      • Règle de décomposition:
      f(t₁, …, tₙ) = f (u₁, …, uₙ) →
      alors on rajoute les nouveaux problèmes
      tᵢ = uᵢ

      f(t₁, …, tₙ) = g(u₁, …, uₘ) → ⊥

***** Généralisation

      let id = fun x -> x in (id 0, id true)

      (x : α) |- x : α
      —————————————————————————–
      |- fun x -> x : α -> α
      —————————————————————————–
      |- fun x -> x : ∀α. α -> α     (id : ∀α. α -> α) ⊢ (id 0, id true) : int × bool
      ————————————————————————————————————————————————————–————————————–————————————–
                |- let id = fun x -> x in (id 0, id true) : int × bool

**** La génération de contraintes

     [ let apply = fun f x -> f x ] =

     def apply : ∀α[∃γβγ₁γ₂. α = γ₁ -> γ₂ ∧ γ₁ = (γ -> β) ∧ γ₂ = γ -> β].α

** Jalon 3
** Datix
** Hopix -> Datix
*** Compilation du pattern-matching
**** avec des "ifs"

     En Hopix:

       fun len (l) = l ? Nil => 0 | Cons (x, xs) => 1 + len (xs)

     est compilé en Datix comme suit:

       fun len (l) =
	 if l[0] = 0 then
	   0
	 else if l[0] = 1 then
	   val x = l[1];
	   val xs = l[2];
	   1 + len (xs)

      Un autre exemple:

        fun uniq (l) = l ? {
	| Nil => true
	| Cons (x, Nil) => true
        | Cons (x, Cons (y, xs)) => x <> y && uniq (Cons (y, xs))
        }

      est compilé:

        fun uniq (l) =
          if l[0] = 0 then
            true
          else if l[0] = 1 && l[2][0] = 0 then
            true
          else if l[0] = 1 && l[2][0] = 1 then
            val x = l[1];
            val y = l[2][1];
	    val xs = l[2][2];
            x <> y && uniq (val b = block 2; b[0] = 1; b[1] = y; b[2] = xs)

        fun uniq (l) =
          switch l[0] {
	  case 0:
	     true
	  case 1:
	     switch l[2][0] {
	       case 0: 
	          true
	       case 1:
                  val x = l[1];
                  val y = l[2][1];
    	          val xs = l[2][2];
                  x <> y && uniq (val b = block 2; b[0] = 1; b[1] = y; b[2] = xs)
	     }
          }
